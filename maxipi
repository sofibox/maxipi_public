#!/bin/bash
#"=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
umask 077
# ==================================================
_APP_SPECIFIC_NAME="Maxipi"
_APP_VERSION="1.0"
_APP_STATUS="alpha"
_APP_INFO="${_APP_SPECIFIC_NAME} is a bash script used for executing API from various providers
such as linode, Digitalocean, Microsoft Azure, CloudFlare, Directadmin and etc"
_APP_VERSION_STATUS="${_APP_VERSION}-${_APP_STATUS}"
_AUTHOR="Author: Arafat Ali | Email: arafat@sofibox.com | (C) 2019-2022"
# ====================================================
# TESTING
# Testing again remember this is an alpha version im testing again.. and i will remove this repo and start again with beta version

# start TODO_LIST
# TODO add API setup for linode (and others)
# end TODO_LIST

# requirements
# This script use the enhanced getopt (for implementing long options), Most GNU distro came with enhanced getopt to run this script.
# The getopt only use in sub function

# This is used to display script help file
usage() {
  local usage_file
  usage_file="${SCRIPT_PATH}/readme.txt"
  if [ -f "${usage_file}" ]; then
    cat "${SCRIPT_PATH}/readme.txt"
    echo ""
  else
    echo "Error, the usage file ${usage_file} does not exist."
    exit 1
  fi
}
script_update() {
  local caller current_configs new_configs

  caller="${SCRIPT_NAME}->${FUNCNAME[0]}"

  echo "[${caller}]: Updating ${SCRIPT_NAME} to latest version ..."
  navigate_to "${SCRIPT_INSTALL_PATH}"
  echo ""
  echo "START git update information:"
  git fetch --all
  status_handler check --code $?
  git reset --hard origin/main
  status_handler check --code $?
  echo "END git update information:"
  echo ""
  navigate_to "PREVIOUS"
  echo ""

  echo "[${caller}]: Updating ${SCRIPT_NAME} configuration file ..."

  # This will add a new config variable into the config file if it does not exist
  # It will not disturb variable that already has value. So you do not need to reconfigure the script
  # If config contain invalid value like having no equal sign, it will also replace them with a new variable from sample config

  current_configs=$(grep -E '^[A-Za-z0-9_].+=.+$' "${SCRIPT_INSTALL_PATH}/${SCRIPT_NAME}.conf" | awk -F "=" '{print $1}')
  new_configs=$(grep -E '^[A-Za-z0-9_].+=.+$' "${SCRIPT_INSTALL_PATH}/${SCRIPT_NAME}.conf.sample" | awk -F "=" '{print $1}')

  for new_config in ${new_configs}; do
    if [[ ${current_configs} =~ ${new_config} ]]; then
      :
    else
      echo "Adding new config: ${new_config} into ${SCRIPT_INSTALL_PATH}/${SCRIPT_NAME}.conf"
      echo "${new_config}=\"\"" >>"${SCRIPT_INSTALL_PATH}/${SCRIPT_NAME}.conf"
      status_handler check --code $?
    fi
  done

  # Remove blank lines, comments and sort config file
  grep -E '^[A-Za-z0-9_].+=.+$' "${SCRIPT_INSTALL_PATH}/${SCRIPT_NAME}.conf" | sort >"${SCRIPT_INSTALL_PATH}/${SCRIPT_NAME}.conf_tmp"
  mv "${SCRIPT_INSTALL_PATH}/${SCRIPT_NAME}.conf_tmp" "${SCRIPT_INSTALL_PATH}/${SCRIPT_NAME}.conf"

  echo "[${caller}]: Running ${SCRIPT_NAME} -V ..."
  chmod +x "${SCRIPT_INSTALL_PATH}/${SCRIPT_NAME}"
  ${SCRIPT_NAME} -V
  status_handler check --code $?

}

# This is used to check script for update
check_update() {
  local caller temp_file
  caller="${SCRIPT_NAME}->${FUNCNAME[0]}"
  echo "[${caller}]: Checking ${SCRIPT_NAME} for update..."
  temp_file="${TEMP_PATH}/maxipi"
  # The github raw hosting will not be updated immediately after I push the update to github. Need to wait about 5 minutes
  curl -H 'Cache-Control: no-cache' -so "${temp_file}" "https://raw.githubusercontent.com/sofibox/maxipi_public/main/maxipi"
  status_handler check --code $?
  available_version="$(awk -F'=' '/^_APP_VERSION=/{ print $2 }' "${temp_file}" | sed 's/\"//g')"
  this_version="${_APP_VERSION}"
  echo ""
  echo "Installed version is: v${this_version}"
  echo "Online version is: v${available_version}"
  echo ""
  if [[ "ok" == "$(echo | awk "(${available_version} > ${this_version}) { print \"ok\"; }")" ]]; then
    echo "[${caller}]: A new version of ${SCRIPT_NAME} is available."
    _confirm "[${caller}->input]: Do you want to update ${SCRIPT_NAME} to version ${available_version}?" "y"
    script_update
  elif [[ "ok" == "$(echo | awk "(${available_version} == ${this_version}) { print \"ok\"; }")" ]]; then
    echo "[${caller}]: You are using the latest version of ${SCRIPT_NAME}."
  else
    echo "[${caller}]: You are using a newer version of ${SCRIPT_NAME} than the latest available."
  fi

  rm -f "${temp_file}"
}

manual() {
  # This will show specific help name
  local api_provider api_action
  api_provider="$1"
  api_action="$2"
  echo "HELP MANUAL"
  echo "==========="
  echo ""
  if [ "${api_provider}" == "linode_api" ]; then

    if [ "${api_action}" == "get-linode-id" ]; then
      echo "linode_api->get-linode-id"
      echo ""
      echo "Required: --linode-label<LINODE_LABEL> or --server-label <LINODE_LABEL>"
      echo ""
      echo "Example:"
      echo "${SCRIPT_NAME} linode get-linode-id --linode-label sun.sofibox.com"
      echo ""
      echo "Output:"
      echo "12345"
    fi

  fi
}

to_ordinal() {
  local integer
  integer="$1"
  case "${integer}" in
  *1[0-9] | *[04-9]) echo "${integer}"th ;;
  *1) echo "${integer}"st ;;
  *2) echo "${integer}"nd ;;
  *3) echo "${integer}"rd ;;
  esac
}

# This function is used to terminate a current running script.
# pass the normal exit code
# syntax: _exit <exit_code>
# eg: _exit 3
_exit() {
  exit "$1"
}

# This function is used to return value of a current running script.
# pass the normal return code
# syntax: _return <return_code>
# eg: _return 3

_return() {
  return "$1"
}
# ask for confirmation
# syntax:
# _confirm <text_string> <default_response_key>
# example:
# _confirm are you sure you want to do this? y
_confirm() {
  local text default_response
  text=$1
  default_response=$2
  if [ -z "${default_response}" ]; then
    default_response="Y"
  fi
  read -r -p "${text} [default:${default_response}] [Y/n]: " response
  # Simulate a default response so that we can press Enter key
  if [[ -z "${response}" ]]; then
    response="${default_response}"
  fi
  if [[ "$response" =~ ^([yY][eE][sS]|[yY])$ ]]; then
    return 0
  else
    echo "[${SCRIPT_NAME}->${FUNCNAME[0]}->cancel]: Operation aborted!"
    exit 0
  fi
}

navigate_to() {
  local to_path="$1"
  if [[ "${to_path^^}" == +(PRE|PREVIOUS|OLDPATH|BACK|OLDPWD) ]]; then
    # OLD_PATH holds a previous path (see global variable of PREPATH in this script)
    echo "[${SCRIPT_NAME}]: Navigating out into ${OLD_PATH} ..."
    to_path="${OLD_PATH}"
  else
    echo "[${SCRIPT_NAME}]: Navigating into ${to_path} ..."
    OLD_PATH="${PWD}"
  fi

  cd "${to_path}" || {
    echo "[${SCRIPT_NAME}]: Error, failed to enter into the directory ${to_path}"
    _exit 1
  }

}

# This will install required components for the current OS
# It will not do anything if the required components exist
# Syntax:
# required_package htop vim
required_packages() {

  local required_cmds="$*" detect_by missing_count install_success install_failed retval

  ((missing_count = install_success = install_failed = 0))

  # Loop through the received arguments. Do not quote the array, we want split elements:
  for required_cmd in ${required_cmds[*]}; do

    # Using command to obtain installation status
    command -v "${required_cmd}" >/dev/null
    cmd_status="$?"

    [[ "${cmd_status}" -eq 1 ]] && detect_by="cmd_status"

    if [[ "${cmd_status}" -eq 1 ]]; then
      ((missing_count++))
      echo ""
      echo "[${SCRIPT_NAME}]: Warning, missing ${required_cmd} component detected by ${detect_by}"
      # This prevents error if we never run apt-get update when the apt cache is expired
      # When the first missing package is triggered, then we display warning message,
      # and for this first time, we trigger update command to refresh the expired apt cache
      if [ "${missing_count}" -eq 1 ]; then
        echo ""
        echo "[${SCRIPT_NAME}]: Running apt-get update for the first time ..."
        apt-get -qq -y update
        echo ""
      fi
      echo "[${SCRIPT_NAME}]: Installing the $(to_ordinal "${missing_count}") missing component: ${required_cmd} ..."
      echo ""

      if [ "${required_cmd}" == "linode-cli" ]; then
        # local linode_cli_expect_string
        # Install required packages to enable linode-cli command
        _confirm "Do you want to install linode-cli and its packages?"
        apt-get -y install python3-pip
        pip3 install linode-cli --upgrade

        if [ ! -s /root/.config/linode-cli ]; then
          echo "[${SCRIPT_NAME}]: Writing a new API config file at /root/.config/linode-cli ..."
          mkdir -p /root/.config
          touch /root/.config/linode-cli
          {
            echo "[DEFAULT]"
            echo "default-user = ${LINODE_API_USERNAME}"
            echo "[${LINODE_API_USERNAME}]"
            echo "token = ${LINODE_API_KEY}"
          } >/root/.config/linode-cli

          # Another method of linode-cli config setup which is by using expect command
          # echo "[${SCRIPT_NAME}]: Configuring linode-cli using expect ..."
          # if ! command -v expect &>/dev/null; then
          #  apt-get -y install expect
          # fi
          # linode_cli_expect_string=$(expect -c "
          #                    set timeout 3
          #                    spawn linode-cli
          #                    expect \"Personal Access Token:\"
          #                    send \"${LINODE_API_KEY}\r\"
          #                    expect \"Default Region (Optional):\"
          #                    send \"\r\"
          #                    expect \"Default Type of Linode (Optional):\"
          #                    send \"\r\"
          #                    expect \"Default Image (Optional):\"
          #                    send \"\r\"
          #                    expect eof
          #                    ")
          # echo "Expect command summary: "
          # echo "${linode_cli_expect_string}"
        fi

        # linode-cli --version
      elif [ "${required_cmd}" == "mail" ]; then
        _confirm "Do you want to install mailutils?"
        apt-get -y install mailutils
        retval=$?
      elif [ "${required_cmd}" == "ipcalc" ]; then
        _confirm "Do you want to install ipcalc and its components?"
        echo "[${SCRIPT_NAME}]: Installing required packages to build ipcalc"
        sudo apt-get -y install git gcc meson
        echo "[${SCRIPT_NAME}]: Removing existing ipcalc ..."
        apt-get -y remove ipcalc
        rm -rf "/usr/local/bin/ipcalc"
        rm -rf "/opt/ipcalc"
        echo ""
        mkdir -p /opt/ipcalc
        echo "[${SCRIPT_NAME}]: Installing ipcalc from source https://github.com/sofibox/ipcalc.git ..."
        git clone https://github.com/sofibox/ipcalc.git "/opt/ipcalc"
        navigate_to "/opt/ipcalc"
        meson setup build --buildtype=release
        ninja -C build
        echo ""
        ln -s /opt/ipcalc/build/ipcalc /usr/local/bin
        ipcalc --version
        retval=$?
      elif [ "${required_cmd}" == "packagecommand3" ]; then
        # Do another type of installation method for this package command name example install from source
        :
      else
        # Do apt installation
        apt-get -y install "${required_cmd}"
        retval=$?
      fi

      if [[ "${retval}" -eq 0 ]]; then
        ((install_success++))
      else
        ((install_failed++))
      fi
    fi
  done
  if [ "${install_failed}" -gt 0 ]; then
    echo ""
    echo "Total missing component: ${missing_count}"
    echo "Total success installed: ${install_success}"
    echo "Total failed installed: ${install_failed}"
    echo ""
  fi
}

# Alias of error_handler
status_code() {
  status_handler "$@"
}

# Alias of error_handler
error_handler() {
  status_handler "$@"
}
# Example:
# Check normal code with description 1
#status_code check --code "$?" --for "curl"
# check curl code with http code
#status_code check --curl-code ${curl_code} --http-code ${http_response_code}
# check only http code
#status_code check --http-code ${code_1}
status_handler() {

  local action argnum caller options retval code description curl_code http_code print_success print_curl_success print_http_success scripting error_msg success_msg
  action="$1"
  argnum="$#"
  caller="${SCRIPT_NAME}->${FUNCNAME[0]}"

  if [ ${argnum} -eq 0 ]; then
    echo "[${caller}]: Error, no argument is supplied. Use [ ${SCRIPT_NAME} --create-var --help ] to see the valid options"
    exit 1
  fi
  short_opts="c:,d:"
  long_opts="code:,description:,for:,desc:,error-msg:,curl-code:,curl-status:,http-code:,http-status:,print-success,print-curl-success,print-http-success,print-response-success,error-message:,error-msg:,success-message:,success-msg:"
  options=$(getopt -o "${short_opts}" --long "${long_opts}" -n "[${caller}]" -- "$@")
  retval=$?
  if [ "${retval}" != 0 ]; then
    echo "[${caller}]: Error, invalid options. Terminating..."
    _exit 1
  fi

  eval set -- "${options}"

  code=""
  description=""
  curl_code=""
  http_code=""
  print_success=false
  print_curl_success=false
  print_http_success=false
  scripting="${SCRIPTING}"
  error_msg=""
  success_msg=""
  while true; do
    case "$1" in
    --help)
      manual "${FUNCNAME[0]}"
      shift
      exit 0
      ;;
    -c | --code)
      code="$2"
      shift 2
      ;;
    -d | --for | --description | --desc)
      description="$2"
      shift 2
      ;;
    --error-msg)
      error_msg="$2"
      shift 2
      ;;
    --success-msg)
      success_msg="$2"
      shift 2
      ;;
    --curl-code | --curl-status)
      curl_code="$2"
      shift 2
      ;;
    --http-code | --http-status)
      http_code="$2"
      shift 2
      ;;

    --print-success)
      print_success=true
      shift
      ;;
    --print-curl-success)
      print_curl_success=true
      shift
      ;;
    --print-http-success | --print-response-success)
      print_http_success=true
      shift
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
    esac
  done

  if [[ "${action}" == "get-status-code" || "${action}" == "get-status" || "${action}" == "check-status" || "${action}" == "get" || "${action}" == "check" ]]; then

    # If the variable code is set, this will take precedence over the others curl_code and http_code if error occurred
    if [ -n "${code}" ]; then
      if [ "${code}" -eq 0 ]; then
        if [[ "${print_success}" == true && "${scripting}" == false ]]; then
          if [ -n "${success_msg}" ]; then
            echo "[${caller}->status]: Success, ${success_msg}"
          else
            echo "[${caller}->status]: [ Success ]"
          fi
        fi
        [[ "${print_success}" == true && "${scripting}" == true ]] && echo "success"
        _return 0
      # Write more return code here to handle errors
      # elif [ "${code}" -eq 1 ]; then

      else
        if [[ ${scripting} == "false" ]]; then
          if [ -n "${error_msg}" ]; then
            echo "[${caller}->status]: Error(${code}), ${error_msg}"
          else
            echo "[${caller}->status]: [ Error(${code}) ]"
          fi
        else
          echo "error"
        fi
        _exit "${code}"
      fi

    fi

    if [ -n "${curl_code}" ]; then
      if [ "${curl_code}" -eq 0 ]; then
        if [[ "${print_curl_success}" == true && "${scripting}" == false ]]; then
          if [ -n "${success_msg}" ]; then
            echo "[${caller}->curl]: Success, ${success_msg}"
          else
            echo "[${caller}->curl]: [ Success ]"
          fi
        fi

        [[ "${print_curl_success}" == true && "${scripting}" == true ]] && echo "success"

        _return 0
        # Write more curl return code here to handle errors
      # elif [ "${curl_code}" -eq 1 ]; then
      else
        if [[ ${scripting} == false ]]; then
          if [ -n "${error_msg}" ]; then
            echo "[${caller}->curl]: Error(${curl_code}), ${error_msg}"
          else
            echo "[${caller}->curl]: [ Error(${curl_code}) ]"
          fi
        else
          echo "error"
        fi
        _exit "${curl_code}"
      fi
    fi

    if [ -n "${http_code}" ]; then
      if [ "${API_PROVIDER}" == "linode" ]; then
        if [ "${http_code}" == "200" ]; then

          if [[ "${print_http_success}" == true && "${scripting}" == false ]]; then
            echo ""
            echo "Success response: "
            jq . "${RESPONSE_FILE}"
            echo ""
            if [ -n "${success_msg}" ]; then
              echo "[${caller}->http]: Success, ${success_msg}"
            else
              echo "[${caller}->http]: [ Success ]"
            fi
          fi

          [[ "${scripting}" == true ]] && echo "success"
          _return 0
        # Write more http return code here to handle errors
        # elif [ "${http_code}" == "401" ]; then
        else
          if [[ ${scripting} == false ]]; then
            if [ -n "${error_msg}" ]; then
              echo "[${caller}->http]: Error(${http_code}), ${error_msg}"
            else
              echo "[${caller}->http]: [ Error(${http_code}) ]"
            fi
            echo "Response details:"
            jq . "${RESPONSE_FILE}"
            echo ""
          else
            echo "error"
          fi
          _exit "${http_code}"
        fi

      elif [ "${API_PROVIDER}" == "directadmin" ]; then
        if [ "${http_code}" == "200" ]; then

          if [[ "${print_http_success}" == true && "${scripting}" == false ]]; then
            echo ""
            echo "Success response: "
            jq . "${RESPONSE_FILE}"
            echo ""
            if [ -n "${success_msg}" ]; then
              echo "[${caller}->http]: Success, ${success_msg}"
            else
              echo "[${caller}->http]: [ Success ]"
            fi
          fi

          [[ "${scripting}" == true ]] && echo "success"
          _return 0
        # Write more http return code here to handle errors
        # elif [ "${http_code}" == "401" ]; then
        else
          if [[ ${scripting} == false ]]; then
            if [ -n "${error_msg}" ]; then
              echo "[${caller}->http]: Error(${http_code}), ${error_msg}"
            else
              echo "[${caller}->http]: [ Error(${http_code}) ]"
            fi
            echo "Response details:"
            jq . "${RESPONSE_FILE}"
            echo ""
          else
            echo "error"
          fi
          _exit "${http_code}"
        fi
      # Handle more provider here
      elif [ "${API_PROVIDER}" == "digitalocean" ]; then
        :
      fi
    fi
  elif

    [ "${action}" == "other_commands" ]
  then
    :
  else
    echo "[${caller}]: Error, invalid action for status_code function"
    _exit 1
  fi

}

# This function validate all data argument. Eg: check if the domain name provided is FQDN or valid
# is_valid server_record_type <data>
is_valid() {
  local type data1 data2 retval
  type="$1"
  data1="$2"
  data2="$3"

  # This is used to compare between 2 version number in floating point
  # is_valid version_required  <required_version> <current_version>
  if [[ "${type}" == "version_required" || "${type}" == "version_needed" ]]; then
    local current_version required_version
    required_version="${data1}"
    current_version="${data2}"
    if [ "$(printf '%s\n' "${required_version}" "${current_version}" | sort -V | head -n1)" = "${required_version}" ]; then
      _return 0
    else
      _return 1
    fi
  # This will check if the given domain and IPv4 are resolved to each other
  elif [[ "${type}" == "ipv4-resolved" || "${type}" == "ipv4_resolved" ]]; then
    required_packages "dnsutils"
    local ipv4 ipv4_propagated domain
    ipv4="${data1}"
    domain="${data2}"
    if [ -z "${domain}" ]; then
      domain="${C_BOX_HOSTNAME_FQHN}"
    fi
    ipv4_propagated=$(dig "${domain}" A +short)
    if [ "${ipv4_propagated}" = "${ipv4}" ]; then
      _return 0
    else
      _return 1
    fi

    # This will check if the given domain and IPv6 are resolved to each other
  elif [[ "${type}" == "ipv6-resolved" || "${type}" == "ipv6_resolved" ]]; then
    required_packages "dnsutils"
    local ipv6 ipv6_propagated domain
    ipv6="${data1}"
    domain="${data2}"
    if [ -z "${domain}" ]; then
      domain="${C_BOX_HOSTNAME_FQHN}"
    fi
    ipv6_propagated=$(dig "${domain}" AAAA +short)
    if [ "${ipv6_propagated}" == "${ipv6}" ]; then
      _return 0
    else
      _return 1
    fi

  # This will check IPv4 prefix is valid from /1 to /32
  elif [[ "${type}" == "ipv4_prefix" ]]; then
    local ipv4_prefix ipv4_prefix_pattern
    ipv4_prefix="${data1}"
    ipv4_prefix_pattern='^(\/)\b([1-9]|[1-2][0-9]|3[0-1])\b'
    if [[ ${ipv4_prefix} =~ ${ipv4_prefix_pattern} ]]; then
      return 0
    else
      return 1
    fi

  # This will check IPv6 prefix is valid from /1 to /128
  elif [[ "${type}" == "ipv6_prefix" ]]; then
    local ipv6_prefix ipv6_prefix_pattern
    ipv6_prefix="${data1}"
    ipv6_prefix_pattern="^^(\/)\b([1-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])\b$"
    if [[ ${ipv6_prefix} =~ ${ipv6_prefix_pattern} ]]; then
      _return 0
    else
      _return 1
    fi

    # This will check both IPv4 and IPv6 prefix is valid from /1 to /32 and /1 to /128
  elif [[ "${type}" == "ipv4_ipv6_prefix" ]]; then
    local ipv4_ipv6_prefix ipv4_ipv6_prefix_pattern
    ipv4_ipv6_prefix="${data1}"
    ipv4_ipv6_prefix_pattern="^(\/)\b([1-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8]|3[0-1])\b$"

    if [[ ${ipv4_ipv6_prefix} =~ ${ipv4_ipv6_prefix_pattern} ]]; then
      return 0
    else
      return 1
    fi
  # Check if IPv4 netmask is valid from 128.0.0.0 to 255.255.255.255 (32 IPs)
  elif [[ "${type}" == "ipv4_netmask" || "${type}" == "ipv4_subnet" ]]; then
    local ipv4_netmask ipv4_netmask_pattern
    ipv4_netmask="${data1}"
    ipv4_netmask_pattern='^(128|192|224|240|248|252|254|255)\.0\.0\.0|255\.(0|128|192|224|240|248|252|254|255)\.0\.0|255\.255\.(0|128|192|224|240|248|252|254|255)\.0|255\.255\.255\.(0|128|192|224|240|248|252|254|255)$'
    if [[ ${ipv4_netmask} =~ ${ipv4_netmask_pattern} ]]; then
      return 0
    else
      return 1
    fi
    # Check if Ipv6 netmask is valid from 8000:: to ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff (128 IPs)
    # TODO ipv6_netmask
  elif [[ "${type}" == "ipv6_netmask" || "${type}" == "ipv6_subnet" ]]; then
    local ipv6_netmask ipv6_netmask_pattern
    echo "DO NOT USE THIS YET ipv6_netmask"
    _exit 1
    ipv6_netmask="${data1}"
    ipv6_netmask_pattern=""
    # This is used to check if the given domain has SSL certificate (or is valid https)
    if [[ ${ipv4_netmask} =~ ${ipv4_netmask_pattern} ]]; then
      return 0
    else
      return 1
    fi
  elif [[ "${type}" == "ssl_site" ]]; then
    local url final_hostname status
    url="${data1}"
    final_hostname=$(timeout 3 curl "${url}" -s -L -I -o /dev/null -w '%{url_effective}' | awk -F[/:] '{print $4}')
    status=$(curl --cert-status -v "https://${final_hostname}" 2>&1 | awk 'BEGIN { cert=0 } /^\* Server certificate:/ { cert=1 } /^\*/ { if (cert) print }' | grep "\*  SSL certificate verify ok.")
    if [ -z "${status}" ]; then
      _return 1
    else
      _return 0
    fi
  # is_valid available_port <server> <port>
  # This function will check if defined server and port is available (in a listening state)
  # Usage: available_port <server> <port>
  # eg: available_port test.sofibox.com 22
  # It will return 0 (if available), and other return codes (if listening state for the port is not available)
  elif [[ "${type}" == "available_port" ]]; then
    local server port retval
    server="${data1}"
    port="${data2}"
    nc -z -v -w5 "${server}" "${port}" 2>/dev/null
    retval=$?
    _return ${retval}

  elif [[ "${type}" == "integer" ]]; then
    if [[ ${data1} =~ [0-9] ]]; then
      _return 0
    else
      _return 1
    fi
  elif [[ "${type}" == "domain" ]]; then
    if grep -oP '(?=^.{1,254}$)(^(?>(?!\d+\.)[a-zA-Z0-9_\-]{1,63}\.?)+(?:[a-zA-Z]{2,})$)' <<<"${data1}" >/dev/null 2>&1; then
      _return 0
      # do another check using host if regex above detected as false
    else
      host "${data1}" >/dev/null 2>&1
      retval=$?
      _return "${retval}"
    fi

  elif [[ "${type}" == "domain_type" ]]; then
    # Convert to capital with ^^ and compare with capital letters
    if [[ "${data1^^}" == +(MASTER|SLAVE) ]]; then
      _return 0
    else
      _return 1
    fi
    # For linode case ttl
    #  record_ttl="300" # 300(5m), 3600(1h), 7200(2h), 14400(4h), 28800(8h), 57600(16h), 0/86400(1d)-Default, 172800(2d), 345600(4d), 691200(8d), 604800(1w), 1209600(2w), 2419200(4w).
  elif [[ "${type}" == "domain_ttl" ]]; then
    if [[ ${data1} -ge 30 && ${data1} -le 2419200 && ${data1} =~ ^[0-9]+$ ]]; then
      _return 0
    else
      _return 1
    fi
  elif [[ "${type}" == "domain_status" ]]; then
    if [[ "${data1^^}" == +(ACTIVE|DISABLED) ]]; then
      _return 0
    else
      _return 1
    fi
  elif [[ "${type}" == "record_ttl" ]]; then
    if [[ ${data1} -ge 30 && ${data1} -le 2419200 && ${data1} =~ ^[0-9]+$ ]]; then
      _return 0
    else
      _return 1
    fi
  elif [[ "${type}" == "record_type" ]]; then
    # Convert to capital with ^^ and compare with capital letters
    if [[ "${data1^^}" == +(NS|MX|A|AAAA|TXT|CNAME|SRV|CAA) ]]; then
      _return 0
    else
      _return 1
    fi
  elif [[ "${type}" == "record_priority" ]]; then
    if [[ ${data1} -ge 0 && ${data1} -le 255 && ${data1} =~ ^[0-9]+$ ]]; then
      _return 0
    else
      _return 1
    fi
  elif [[ "${type}" == "email" ]]; then
    if [[ "${data1}" =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$ ]]; then
      _return 0
    else
      _return 1
    fi
  elif [[ "${type}" == "server_record_valid_character" ]]; then
    # It accepts underscore
    if [[ "${data1}" == *['!'@#\$%^\&*()_+\[\]\\?/.,\>\<:{}\|=]* ]]; then
      _return 1
    else
      _return 0
    fi
    # Check if it is a valid ipv4 address
  elif [[ "${type}" == "ipv4" ]]; then
    local ipv4="${data1}" retval

    # Old method
    # local ipv4="${data1}" ipv4_pattern='^(([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))\.){3}([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))$'
    #if [[ "${ipv4}" =~ ${ipv4_pattern} ]]; then
    #  retval=0
    #else
    #  retval=1
    #fi

    # New method that is more accurate using enchanced ipcalc (put as requirement)
    if ipcalc -s -4 -c "${ipv4}"; then
      #echo "valid IPv4"
      retval=0
    else
      #echo "Invalid IPv4"
      retval=1
    fi

    _return ${retval}
    # Check if it is a valid ipv6 address
  elif [[ "${type}" == "ipv6" ]]; then
    local ipv6="${data1}" retval

    # Old method
    #ipv6_pattern='^([0-9a-fA-F]{0,4}:){1,7}[0-9a-fA-F]{0,4}$'
    #if [[ ${ipv6} =~ ${ipv6_pattern} ]]; then
    #  retval=0
    #else
    #  retval=1
    #fi

    # New method that is more accurate using enhanced ipcalc (put as requirement)
    if ipcalc -s -6 -c "${ipv6}"; then
      #echo "valid IPv6"
      retval=0
    else
      #echo "Invalid IPv6"
      retval=1
    fi

    _return ${retval}

    # Check both ipv4 and ipv6
  elif [[ "${type}" == "ipv46" ]]; then
    local ipv46="${data1}" retval

    if ipcalc -s -c "${ipv46}"; then
      # echo "valid IPv4 or IPv6"
      retval=0
    else
      # echo "Invalid IPv4 or IPv6"
      retval=1
    fi

    _return ${retval}
  elif [[ "${type}" == "not-empty-string" ]]; then
    if [ -n "${data1}" ]; then
      _return 0
    else
      _return 1
    fi
  elif [[ "${type}" == "valid-linode-disk-filetype" ]]; then
    if [[ "${data1^^}" == +(RAW|SWAP|EXT3|EXT4|INITRD) ]]; then
      _return 0
    else
      _return 1
    fi
    # if is_valid sha256sum data1 data2; then
  elif [[ "${type}" == "sha256sum" ]]; then
    local retval
    echo "${data1}" "${data2}" | sha256sum --check &>/dev/null
    retval=$?
    _return ${retval}
  fi
}

# Convert boolean. Example if pass true, yes, enable, 1 will be converted to true
convert_boolean_alias() {

  local option data
  option="$1"
  data="$2"

  if [[ "${data^^}" == +(TRUE|YES|ENABLE|1) ]]; then
    echo "true"
    _return 0
  elif [[ "${data^^}" == +(FALSE|NO|DISABLE|0) ]]; then
    echo "false"
    _return 0
  else
    echo "[${caller}]: Error, invalid value given for option ${option}. Use --help to see the valid options"
    _exit 1
  fi
}

# This is a linode API call function
linode_api() {
  local action argnum caller retval short_opts long_opts options linode_max_page_size api_url api_auth_string

  # Use token from linode-cli config if exist

  if [ -s "/root/.config/linode-cli" ]; then
    LINODE_API_USERNAME=$(awk '/^default-user/{ print $NF }' /root/.config/linode-cli)
    LINODE_API_KEY=$(awk '/^token/{ print $NF }' /root/.config/linode-cli)
  fi

  action="$1"
  argnum="$#"

  # label for script caller
  caller="${SCRIPT_NAME}->${FUNCNAME[0]}"

  API_PROVIDER="linode"

  api_url="${LINODE_API_PROTOCOL}://${LINODE_API_DOMAIN}"

  api_auth_string="Authorization: Bearer ${LINODE_API_KEY}"

  # New code does not require linode-cli. We only need jq to manipulate json data
  required_packages "jq"

  # Return the number of item. Maximum page size is 500 (based on the API test value)
  linode_max_page_size=500

  short_opts="h,c:,v,d,s,q"
  long_opts="help,config-file:,config:,verbose,debug,scripting,without-prompt,quite,ip-address:,hostname:,nameserver:,subdomain:,server:,linode-label:,server-label:,domain:,domain-name:,domain-type:,domain-master-ips:,domain-master-ip:,domain-email:,domain-ttl:,domain-status:,default,default-value,default-data,rebuild,rebuild-value,rebuild-data,force,\
  record-type:,record-name:,record-value:,record-target:,record-ttl:,record-priority:,record-hostname:,record-domain:,record-subdomain:,record-server:,record-nameserver:,record-alias:,for-domain-name:,for-ip-address:,for-ip:,where-ip-address-is:,where-ip-is:,for-domain:,where-domain-name-is:,where-domain-is:,for-linode-label:,for-label:,for-server-label:,for-server:,where-linode-label-is:,where-server-label-is:,for-linode:,for-record-name:,\
  where-record-name-is:,for-record-value:,where-record-value-is:,for-record-type:,where-record-type-is:,for-linode-disk-label:,for-disk-label:,where-linode-disk-label-is:,where-disk-label-is:,for-linode-config-label:,for-config-label:,where-linode-config-label-is:,\
  where-config-label-is:,first-record,last-record,wait-until-linode-status:,wait-until-server-status:,wait-until-disk-status:,max-call:,max-retries:,timeout:,allow-duplicate-entries,shutdown-linode-first,check-busy-status,check-for-busy-status,wait-for-busy-status,label-devsda:,dev-sda:,label-devsdb:,dev-sdb:,\
  label-devsdc:,dev-sdc:,label-devsdd:,dev-sdd:,label-devsde:,dev-sde:,label-devsdf:,dev-sdf:,label-devsdg:,dev-sdg:,label-devsdh:,dev-sdh:,linode-disk-filetype:,disk-filetype:,linode-disk-size:,disk-size:,linode-disk-label:,disk-label:,linode-config-label:,config-label:,\
  linode-config-comments:,config-comments:,linode-config-virtual-mode:,config-virtual-mode:,linode-config-kernel:,config-kernel:,linode-config-runlevel:,config-runlevel:,linode-config-memory-limit:,config-memory-limit:,linode-config-rootdev:,config-rootdev:,linode-config-enable-distro-helper:,config-enable-distro-helper:,linode-config-disable-update-db:, \
  config-disable-update-db:,linode-config-enable-dep-helper:, config-enable-dep-helper:,linode-config-automount-devtmpfs:,config-automount-devtmpfs:,linode-config-autoconf-network:,config-autoconf-network:,linode-enable-watchdog:,enable-watchdog:,linode-ip-address:,get-value:"

  options=$(getopt -o "${short_opts}" --long "${long_opts}" -n "[${caller}]" -- "$@")
  retval=$?

  if [ ${retval} != 0 ]; then
    echo "[${caller}]: Error, invalid option"
    _exit 1
  fi

  eval set -- "${options}"

  local help config_file verbose debug scripting without_prompt quite ip_address hostname nameserver subdomain server linode_label domain_name default_value rebuild_value domain_type domain_master_ips domain_email domain_ttl domain_status record_type record_name record_value record_ttl record_priority \
    record_hostname record_domain record_subdomain record_server record_nameserver record_alias for_linode_label for_domain_name for_ip_address for_record_name for_record_value for_record_type for_linode_disk_label for_linode_config_label first_record last_record wait_until_linode_status wait_until_disk_status max_retries label_devsda label_devsdb label_devsdc label_devsdd label_devsde label_devsdf \
    label_devsdg label_devsdh allow_duplicate_entries shutdown_linode_first check_for_busy_status linode_disk_filetype linode_disk_size linode_disk_label linode_config_label linode_config_comments linode_config_virtual_mode linode_config_kernel \
    linode_config_runlevel linode_config_memory_limit linode_config_rootdev linode_config_enable_distro_helper linode_config_disable_update_db linode_config_enable_dep_helper linode_config_automount_devtmpfs linode_config_autoconf_network \
    linode_enable_watchdog linode_ip_address get_value

  help=false               # true or false
  config_file=""           # config file
  verbose=false            # true or false
  debug=false              # true or false
  scripting="${SCRIPTING}" # true or false based on the global variable SCRIPTING
  without_prompt=false
  quite=false          # true or false
  ip_address=""        # Can be ipv4 or ipv6 address
  hostname=""          # sun.sofibox.com
  nameserver=""        # ns1.sofibox.com
  subdomain=""         # sub
  server=""            # abc.com or mail.abc.com
  linode_label=""      # mars.sofibox.com
  domain_name=""       # abx.com
  default_value=false  # true or false
  rebuild_value=false  # true or false
  domain_type=""       # master, slave
  domain_master_ips="" # 1.2.3.4 or 1.2.3.4 4.5.4.5 ::1 (can be ipv4 or ipv6 or combination of ipv4 and ipv6)
  domain_email=""      # user@test.com
  domain_ttl=""        # 30s 120(2m), 300(5m), 3600(1h), 7200(2h), 14400(4h), 28800(8h), 57600(16h), 0/86400(1d)-Default, 172800(2d), 345600(4d), 691200(8d), 604800(1w), 1209600(2w), 2419200(4w).
  domain_status=""     # disabled, active Default: active
  record_type=""       # a, aaaa, txt, ns, mx, cname, srv, caa
  record_name=""       # _key.test.com
  record_value=""      # 2(,@s*passWok | 1.1.1.1 | ::
  record_ttl=""        # 30s 120(2m), 300(5m), 3600(1h), 7200(2h), 14400(4h), 28800(8h), 57600(16h), 0/86400(1d)-Default, 172800(2d), 345600(4d), 691200(8d), 604800(1w), 1209600(2w), 2419200(4w).
  record_priority=""   # 0-255
  record_hostname=""   # sofibox.com, sun.sofibox.com
  record_domain=""     # sofibox.com, sun.sofibox.com
  record_subdomain=""  # sun
  record_server=""     # sofibox.com, sun.sofibox.com
  record_nameserver="" # ns1.sofibox.com, ns2.sofibox.com
  record_alias=""      # sofibox.com, suns.sofibox.com
  for_linode_label=""  # sun.sofibox.com
  for_domain_name=""   # sofibox.com
  for_ip_address=""    # 1.2.3.4, ::1 (can be ipv4 or ipv6)
  for_record_name=""   # _dkim
  for_record_value=""  # 1.2.3.4
  for_record_type=""   # a, aaaa, txt, ns, mx, cname, srv, caa
  for_linode_disk_label=""
  for_linode_config_label=""
  first_record=false # true or false
  last_record=false  # true or false
  wait_until_linode_status=""
  wait_until_disk_status=""
  max_retries=""
  allow_duplicate_entries=false # boolean option
  shutdown_linode_first=false
  check_for_busy_status=false
  label_devsda=""
  label_devsdb=""
  label_devsdc=""
  label_devsdd=""
  label_devsde=""
  label_devsdf=""
  label_devsdg=""
  label_devsdh=""
  linode_disk_filetype=""                    # raw, swap, ext3, ext4, initrd
  linode_disk_size=""                        # 1MB 2GB 3TB (Minimum supporting unit is MB - same as linode, Max supporting unit is TB), if no unit specified by default is MB
  linode_disk_label=""                       # OS_Disk, My_Disk, Anything
  linode_config_label=""                     # Boot_Config, OS_Config, Anything and good to have the postfix _Config at the end
  linode_config_comments=""                  # This is a config profile comment
  linode_config_virtual_mode="paravirt"      # paravirt, fullvirt. The default value is paravirt if not set
  linode_config_kernel="linode/latest-64bit" # linode/direct-disk (this is and example of the ID for direct disk kernel). Default if not specified is linode/latest-64bit. To get more kernel ID, run linode-cli kernels list
  linode_config_runlevel="default"           # default, single, binbash. The default value if not specified is default
  linode_config_memory_limit=""              # If left empty, would be the maximum RAM SIZE of the system from Config File
  linode_config_rootdev="/dev/sda"           # /dev/sda, /dev/sdb, /custom_path. If not specified default value is /dev/sda
  linode_config_enable_distro_helper=false   # default value in linode is true but here i should make it false for customization
  linode_config_disable_update_db=false      # default value in linode is true but here i should make it false for customization
  linode_config_enable_dep_helper=false      # default value in linode is true but here i should make it false for customization
  linode_config_automount_devtmpfs=false     # default value in linode is true but here i should make it false for customization
  linode_config_autoconf_network=false       # default value in linode is true but here i should make it false for customization
  linode_enable_watchdog=false               # true or false
  linode_ip_address=""                       # 1.1.1.1
  get_value=""
  while true; do
    local option=$1
    case "${option}" in
    -h | --help)
      help=true
      shift
      ;;
    -c | --config | --config-file)
      config_file=$2
      shift 2
      ;;
    -v | --verbose)
      verbose=true
      shift
      ;;
    -d | --debug)
      debug=true
      shift
      ;;
    -s | --scripting)
      SCRIPTING=true
      scripting=${SCRIPTING}
      shift
      ;;
    --without-prompt)
      without_prompt=true
      shift
      ;;
    -q | --quite)
      quite=true
      shift
      ;;
    --ip-address)
      ip_address="$2"
      shift 2
      ;;
    --hostname)
      hostname="$2"
      shift 2
      ;;
    --nameserver)
      nameserver="$2"
      shift 2
      ;;
    --subdomain)
      subdomain="$2"
      shift 2
      ;;
    --server)
      server="$2"
      shift 2
      ;;
    --linode-label | --server-label)
      linode_label="$2"
      shift 2
      ;;
    --domain | --domain-name)
      domain_name="$2"
      shift 2
      ;;
    --default | --default-value | --default-data)
      default_value=true
      shift
      ;;
    --rebuild | --rebuild-value | --rebuild-data | --force)
      rebuild_value=true
      shift
      ;;
    --domain-type)
      domain_type="$2"
      shift 2
      ;;
    --domain-master-ips | --domain-master-ip)
      domain_master_ips="$2"
      shift 2
      ;;
    --domain-email)
      domain_email="$2"
      shift 2
      ;;
    --domain-ttl)
      domain_ttl="$2"
      shift 2
      ;;
    --domain-status)
      domain_status="$2"
      shift 2
      ;;
    --record-type)
      record_type="$2"
      record_type="${record_type^^}"
      shift 2
      ;;
    --record-name)
      record_name="$2"
      shift 2
      ;;
    --record-value | --record-target)
      record_value="$2"
      shift 2
      ;;
    --record-ttl)
      record_ttl="$2"
      shift 2
      ;;
    --record-priority)
      record_priority="$2"
      shift 2
      ;;
    --record-hostname)
      record_hostname="$2"
      shift 2
      ;;
    --record-domain)
      record_domain="$2"
      shift 2
      ;;
    --record-subdomain)
      record_subdomain="$2"
      shift 2
      ;;
    --record-server)
      record_server="$2"
      shift 2
      ;;
    --record-nameserver)
      record_nameserver="$2"
      shift 2
      ;;
    --record-alias)
      record_alias="$2"
      shift 2
      ;;
    --for-linode-label | --for-label | --for-server-label | --for-server | --where-linode-label-is | --where-server-label-is | --where-server-is | --for-linode)
      for_linode_label="$2"
      shift 2
      ;;
    --for-domain-name | --for-domain | --where-domain-name-is | --where-domain-is)
      for_domain_name="$2"
      shift 2
      ;;
    --for-ip-address | --for-ip | --where-ip-address-is | --where-ip-is)
      for_ip_address="$2"
      shift 2
      ;;
    --for-record-name | --where-record-name-is)
      for_record_name="$2"
      shift 2
      ;;
    --for-record-value | --where-record-value-is)
      for_record_value="$2"
      shift 2
      ;;
    --for-record-type | --where-record-type-is)
      for_record_type="$2"
      shift 2
      ;;
    --for-linode-disk-label | --for-disk-label | --where-linode-disk-label-is | --where-disk-label-is)
      for_linode_disk_label="$2"
      shift 2
      ;;
    --for-linode-config-label | --for-config-label | --where-linode-config-label-is | --where-config-label-is)
      for_linode_config_label="$2"
      shift 2
      ;;
    --first-record)
      first_record=true
      shift
      ;;
    --last-record)
      last_record=true
      shift
      ;;
    --wait-until-linode-status | --wait-until-server-status)
      wait_until_linode_status="$2"
      if [[ "${wait_until_linode_status^^}" == +(RUNNING|ONLINE) ]]; then
        wait_until_linode_status="running"
      fi
      shift 2
      ;;
    --wait-until-disk-status)
      wait_until_disk_status="$2"
      if [[ "${wait_until_disk_status^^}" == +(RUNNING|ONLINE|READY) ]]; then
        wait_until_disk_status="ready"
      fi
      shift 2
      ;;
    --max-call | --max-retries | --timeout)
      max_retries="$2"
      shift 2
      ;;
    --allow-duplicate-entries)
      allow_duplicate_entries=true
      shift
      ;;
    --shutdown-linode-first)
      shutdown_linode_first=true
      shift
      ;;
    --check-busy-status | --check-for-busy-status | --wait-for-busy-status)
      check_for_busy_status=true
      shift
      ;;
    --label-devsda | --dev-sda)
      label_devsda="$2"
      shift 2
      ;;
    --label-devsdb | --dev-sdb)
      label_devsdb="$2"
      shift 2
      ;;
    --label-devsdc | --dev-sdc)
      label_devsdc="$2"
      shift 2
      ;;
    --label-devsdd | --dev-sdd)
      label_devsdd="$2"
      shift 2
      ;;
    --label-devsde | --dev-sde)
      label_devsde="$2"
      shift 2
      ;;
    --label-devsdf | --dev-sdf)
      label_devsdf="$2"
      shift 2
      ;;
    --label-devsdg | --dev-sdg)
      label_devsdg="$2"
      shift 2
      ;;
    --label-devsdh | --dev-sdh)
      label_devsdh="$2"
      shift 2
      ;;

    --linode-disk-filetype | --disk-filetype)
      linode_disk_filetype="$2"
      shift 2
      ;;
    --linode-disk-size | --disk-size)
      linode_disk_size="$2"
      temp="${linode_disk_size}"
      # can be 10MB 10 MB or MB10 or MB 10
      # If mistaken input this 10 MB s = 10 s (invalid)
      # If mistaken input this 10 MB GB = 10 GB (valid), it will ignore the first unit
      linode_disk_size=$(echo "${temp}" | grep -Eo '[0-9]+' | tail -n1)
      linode_disk_unit=$(echo "${temp}" | grep -Eo '[[:alpha:]]+' | tail -n1)

      if [ -z "${linode_disk_unit}" ]; then
        linode_disk_unit="MB"
      fi
      if [[ "${linode_disk_unit^^}" == +(MB) ]]; then
        :
      elif [[ "${linode_disk_unit^^}" == +(GB) ]]; then
        ((linode_disk_size = linode_disk_size * 1000))
      elif [[ "${linode_disk_unit^^}" == +(TB) ]]; then
        ((linode_disk_size = linode_disk_size * 1000000))
      fi
      shift 2
      ;;
    --linode-disk-label | --disk-label)
      linode_disk_label="$2"
      shift 2
      ;;
    --linode-config-label | --config-label)
      linode_config_label="$2"
      shift 2
      ;;

    --linode-config-comments | --config-comments)
      linode_config_comments="$2"
      shift 2
      ;;

    --linode-config-virtual-mode | --config-virtual-mode)
      linode_config_virtual_mode="$2"
      shift 2
      ;;

    --linode-config-kernel | --config-kernel)
      linode_config_kernel="$2"
      shift 2
      ;;
    --linode-config-runlevel | --config-runlevel)
      linode_config_runlevel="$2"
      shift 2
      ;;

    --linode-config-memory-limit | --config-memory-limit)
      linode_config_memory_limit="$2"
      shift 2
      ;;
    --linode-config-rootdev | --config-rootdev)
      linode_config_rootdev="$2"
      shift 2
      ;;
    --linode-config-enable-distro-helper | --config-enable-distro-helper)
      linode_config_enable_distro_helper=$(convert_boolean_alias "$1" "$2")
      shift 2
      ;;

    --linode-config-disable-update-db | --config-disable-update-db)
      linode_config_disable_update_db=$(convert_boolean_alias "$1" "$2")
      shift 2
      exit 1
      ;;

    --linode-config-enable-dep-helper | --config-enable-dep-helper)
      linode_config_enable_dep_helper=$(convert_boolean_alias "$1" "$2")
      shift 2
      ;;

    --linode-config-automount-devtmpfs | --config-automount-devtmpfs)
      linode_config_automount_devtmpfs=$(convert_boolean_alias "$1" "$2")
      shift 2
      ;;

    --linode-config-autoconf-network | --config-autoconf-network)
      linode_config_autoconf_network=$(convert_boolean_alias "$1" "$2")
      shift 2
      ;;
    --linode-enable-watchdog | --enable-watchdog)
      linode_enable_watchdog=$(convert_boolean_alias "$1" "$2")
      shift 2
      ;;
    --linode-ip-address)
      linode_ip_address="$2"
      shift 2
      ;;
    --get-value)
      get_value="$2"
      shift 2
      ;;
    --)
      shift
      break
      ;;
    -*)
      opt="$1"
      echo "[${caller}]: Error, invalid option ${opt}. Use --help to see the valid options"
      _exit 1
      ;;
    *)
      break
      ;;
    esac
  done

  test_account() {
    local response_code
    response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "${api_auth_string}" --url "${api_url}/account" | jq -r ".")
    status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success

  }

  # Syntax: wait_status_for linode <linode_label>
  #         wait_status_for disk <linode_id> <disk_id> <disk_label>
  wait_status_for() {

    local for wait_total linode_label linode_status linode_id disk_id disk_label disk_status
    wait_total=0
    for="$1"

    # syntax: wait_status_for linode <linode_label>
    if [ "${for}" == "linode" ]; then
      linode_label="$2"
      if [ -z "${linode_label}" ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode_label value is found"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

      linode_status=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | select(.label == \"${linode_label}\") | .status")
      status_handler check --curl-status "$?"

      [[ -z "${max_retries}" ]] && max_retries=120

      while :; do
        if [[ "${linode_status}" == "${wait_until_linode_status}" ]]; then
          [[ ${scripting} == "false" ]] && echo "[${caller}]: Success, the status of linode --for-linode-label ${linode_label} is now ${linode_status}"
          [[ ${scripting} == "true" ]] && echo "success"
          _exit 0
          # break
        else
          [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, the status of linode --for-linode-label ${linode_label} is ${linode_status}. Waiting for ${wait_until_linode_status} status ... ${wait_total}/${max_retries}"
        fi

        sleep 1
        linode_status=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | select(.label == \"${linode_label}\") | .status")
        status_handler check --curl-status "$?"

        ((wait_total++))

        if [ "${wait_total}" -eq ${max_retries} ]; then
          [[ ${scripting} == "false" ]] && echo "[${caller}]: Warning, the status of linode --where-linode-label-is ${linode_label} has not changed into ${wait_until_linode_status} status after ${max_retries} call(s)"
          [[ ${scripting} == "false" ]] && echo "[${caller}]: This is the maximum waiting time set in --max-wait-time option"
          [[ ${scripting} == "false" ]] && echo "[${caller}]: You may want to visit the linode lish console here to inspect this issue in details: https://cloud.linode.com/linodes/${linode_id}/lish/glish"
          [[ ${scripting} == "true" ]] && echo "error"
          _exit 1
        fi
      done
      # Syntax: wait_status_for disk <linode_id> <disk_id> <disk_label>
      # Variable wait_until_disk_status is passed in option
    elif [ "${for}" == "disk" ]; then
      linode_id="$2"
      disk_id="$3"
      disk_label="$4"

      if [ -z "${linode_id}" ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode_id value is found"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

      if [ -z "${disk_id}" ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no disk_id value is found"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

      disk_status=$(curl -s -H "Content-Type: application/json" -H "${api_auth_string}" --url "${api_url}/linode/instances/${linode_id}/disks/${disk_id}" | jq -r ".status")
      status_handler check --curl-status "$?"

      [[ -z "${max_retries}" ]] && max_retries=60

      while :; do

        if [[ "${disk_status}" == "${wait_until_disk_status}" ]]; then
          [[ ${scripting} == "false" ]] && echo "[${caller}]: Success, the disk status --for-disk-label ${disk_label} is now ${disk_status}"
          [[ ${scripting} == "true" ]] && echo "success"
          _exit 0
          # break
        else
          [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, the status of linode --for-disk-label ${disk_label} is ${disk_status}. Waiting for ${wait_until_disk_status} status ... ${wait_total}/${max_retries}"
        fi
        sleep 1
        disk_status=$(curl -s -H "Content-Type: application/json" -H "${api_auth_string}" --url "${api_url}/linode/instances/${linode_id}/disks/${disk_id}" | jq -r ".status")
        status_handler check --curl-status "$?"

        ((wait_total++))

        if [ "${wait_total}" -eq ${max_retries} ]; then
          [[ ${scripting} == "false" ]] && echo "[${caller}]: Warning, the status of linode --for-disk-label ${disk_label} has not changed into ${wait_until_disk_status} status after ${max_retries} call(s)"
          [[ ${scripting} == "false" ]] && echo "[${caller}]: This is the maximum waiting time set in --max-wait-time option"
          [[ ${scripting} == "false" ]] && echo "[${caller}]: You may want to visit the linode lish console here to inspect this issue in details: https://cloud.linode.com/linodes/${linode_id}/lish/glish"
          [[ ${scripting} == "true" ]] && echo "error"
          _exit 1
        fi
      done
    fi
  }

  # Syntax: check_busy_status_for disk <linode_label>
  #         check_busy-status_for linode <linode_label>
  check_busy_status_for() {

    local for linode_label linode_status busy_status wait_total
    for="$1"
    # Before performing any linode actions, we would have to make sure that linode status is not in one of the following states to prevent "Linode Busy" stuck process:
    # booting, rebooting, shutting_down, provisioning, deleting, migrating, rebuilding, cloning, restoring
    # This is my workaround based on my comment here: https://www.linode.com/community/questions/11588/linodeerrorsapierror-400-linode-busy
    # Syntax check_linode_busy_status <linode_label>
    if [ "${for}" == "linode" ]; then
      linode_label="$2"
      if [ -z "${linode_label}" ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode_label value is found"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

      [[ -z "${max_retries}" ]] && max_retries=120

      wait_total=0
      while :; do

        [[ ${scripting} == "false" ]] && echo "[${caller}]: Checking linode busy status --where-linode-label-is ${linode_label} ... ${wait_total}/${max_retries}"
        sleep 1
        linode_status=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | select(.label == \"${linode_label}\") | .status")
        status_handler check --curl-status "$?"

        # We only want to filter out this status as busy and we only focus the first record
        busy_status=$(echo "${linode_status}" | grep -E "^booting$|^rebooting$|^shutting_down$|^provisioning$|^deleting$|^migrating$|^rebuilding$|^cloning$|^restoring$" | head -n 1)

        # If the busy status is found, we check again until no linode busy status
        if [[ -n "${busy_status}" ]]; then
          [[ ${scripting} == "false" ]] && echo "[${caller}]: Warning, linode is busy with the following status: ${busy_status}. Waiting for non-busy linode status ..."
        else
          break
        fi
        ((wait_total++))

        if [ "${wait_total}" -eq ${max_retries} ]; then
          [[ ${scripting} == "false" ]] && echo "[${caller}]: Warning, linode ${linode_label} is still busy"
          [[ ${scripting} == "false" ]] && echo "[${caller}]: This is the maximum waiting time set in --max-wait-time option"
          [[ ${scripting} == "true" ]] && echo "error"
          _exit 1
        fi
      done
      # This is used to free up linode disk busy status to prevent the linode internal error status called "Linode Busy"
      # This is my workaround based on my comment here: https://www.linode.com/community/questions/11588/linodeerrorsapierror-400-linode-busy
      # Current busy state for linode disk is: not ready, and deleting
    elif [ "${for}" == "disk" ]; then
      linode_label="$2"
      if [ -z "${linode_label}" ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode_label value is found"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

      [[ -z "${max_retries}" ]] && max_retries=120

      wait_total=0

      while :; do
        # Linode ID is required first to check disk status
        linode_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | select(.label == \"${linode_label}\") | .id")
        status_handler check --curl-status "$?"

        [[ ${scripting} == "false" ]] && echo "[${caller}]: Checking linode disk busy status --where-linode-label-is ${linode_label} ... ${wait_total}/${max_retries}"
        sleep 1
        # This will return all the disk status
        disk_status=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances/${linode_id}/disks" | jq -r ".data[] | .status")
        status_handler check --curl-status "$?"

        # We only want to filter out this status as busy and we only focus the first record
        busy_status=$(echo "${disk_status}" | grep -E "^not ready$|^deleting$" | head -n1)

        # If the busy status is found, we check again until no disk busy status is found
        if [[ -n "${busy_status}" ]]; then
          [[ ${scripting} == "false" ]] && echo "[${caller}]: Warning, linode disk is busy with the following status: ${busy_status}. Waiting for non-busy disk status ..."
        else
          break
        fi

        ((wait_total++))

        if [ "${wait_total}" -eq ${max_retries} ]; then
          [[ ${scripting} == "false" ]] && echo "[${caller}]: Warning, linode disk is still busy after timeout"
          [[ ${scripting} == "false" ]] && echo "[${caller}]: This is the maximum waiting time set in --max-wait-time option"
          [[ ${scripting} == "true" ]] && echo "error"
          _exit 1
        fi
      done
    fi
  }

  # The linode shutdown only required linode label
  # This shutdown process automatically wait for offline status
  # syntax shutdown_linode_first <linode_label>
  shutdown_linode_first() {

    local wait_total linode_label linode_id
    linode_label="$1"

    # We just want to make sure again that this for_linode_variable exist
    if [ -z "${linode_label}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --for-linode-label option required a valid value (eg: --for-linode-label sun.sofibox.com)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    linode_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | select(.label == \"${linode_label}\") | .id")
    status_handler check --curl-status "$?"

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Shutting down linode ${linode_label} ( ${linode_id} ) ..."

    response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "Content-Type: application/json" -H "${api_auth_string}" \
      -X POST --url "${api_url}/linode/instances/${linode_id}/shutdown")
    status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success --error-msg "there was something wrong when trying to shutdown linode ${linode_label}" --success-msg "the linode ${linode_label} has been set to shutdown"

    [[ -z "${max_retries}" ]] && max_retries=120

    wait_total=0

    while :; do

      if [[ "${linode_status}" == "offline" ]]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Success, the status of linode --for-linode-label ${linode_label} is offline"
        [[ ${scripting} == "true" ]] && echo "success"
        break
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, the status of linode --for-linode-label ${linode_label} is ${linode_status}. Waiting for offline status ... ${wait_total}/${max_retries}"
      fi
      sleep 1
      linode_status=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | select(.label == \"${linode_label}\") | .status")
      status_handler check --curl-status "$?"

      ((wait_total++))
      if [ "${wait_total}" -eq ${max_retries} ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Warning, the status of linode for --for-linode-label ${linode_label} has not changed into offline status after ${max_retries} call(s)"
        [[ ${scripting} == "false" ]] && echo "[${caller}]: This is the maximum waiting time set in --max-wait-time option"
        [[ ${scripting} == "false" ]] && echo "[${caller}]: You may want to visit the linode lish console here to inspect this issue in details: https://cloud.linode.com/linodes/${linode_id}/lish/glish"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
    done

  }

  # If --config-file option is provided we will use it to get variable LINODE_API_KEY
  if [ -n "${config_file}" ]; then
    if [ -f "${config_file}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, using config file ${config_file} to get variable LINODE_API_KEY"
      local retval
      source "${config_file}"
      retval=$?
      if [ "${retval}" -ne 0 ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, there was something wrong when trying to source the config file ${config_file}"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Success, the config file ${config_file} has been sourced"
      fi
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --config-file option required a valid file path (eg: --config-file /path/to/config/file)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi
  fi

  # We check the linode API token, If it does not exist then we prompt to insert a new token and write to a config file
  # After that we test the account to see if the token is valid. If the token is not valid, you have to correct or remove (or empty the value) from the config file
  if [ -z "${LINODE_API_KEY}" ]; then
    [[ ${scripting} == "false" ]] && echo "[${caller}->input]: Warning, the variable LINODE_API_KEY for linode token has no value! Enter a new linode API token: "
    read -r LINODE_API_KEY
    echo "[${caller}]: Given token is: ${LINODE_API_KEY}"
    _confirm "[${caller}->input]: Do you want to write the token into config file at ${CONFIG_FILE}?"
    sed -i "s|^LINODE_API_KEY\=.*|LINODE_API_KEY=\"${LINODE_API_KEY}\"|" "${CONFIG_FILE}"
    status_handler check --code "$?" --print-success
    echo "[${caller}]: Updating the new linode API header token ..."
    api_auth_string="Authorization: Bearer ${LINODE_API_KEY}"
    echo ""
    [[ ${scripting} == "false" ]] && echo "[${caller}]: Testing the linode account using the new token ... "
    test_account
    _exit 0
  fi

  if [[ "${action^^}" == +(TEST-ACCOUNT|TEST) ]]; then

    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: ${action}"
      echo "Purpose: This action is used for testing account API and show information about the linode account"
      echo "Notes:"
      echo "If you want the script to return success, just pass the option --scripting"
      echo "Example 1:"
      echo "  ${SCRIPT_NAME} linode ${action}"
      echo "Example 2:"
      echo "  ${SCRIPT_NAME} linode ${action} --scripting"
      echo ""
      _exit 0
    fi

    test_account

  elif [[ "${action^^}" == +(GET-ID|GET-LINODE-ID|SERVER-ID|GET-SERVER-ID) ]]; then
    local linode_id

    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: ${action}"
      echo "Required option(s): --for-linode-label <linode label>"
      echo "Purpose: This action is used to get a linode ID based on a given linode label"
      echo "Notes:"
      echo "You cannot have the same linode names for all your servers (linode rule). So this action will only return 1 ID"
      echo "Example 1:"
      echo "  ${SCRIPT_NAME} linode ${action} --for-linode-label sun.sofibox.com"
      echo "Example 2:"
      echo "  ${SCRIPT_NAME} linode ${action} --where-linode-label-is sun.sofibox.com"
      echo "Example 3:"
      echo "  ${SCRIPT_NAME} linode ${action} --where-label-is sun.sofibox.com"
      echo "Example 4:"
      echo "  ${SCRIPT_NAME} linode ${action} --where-server-label-is sun.sofibox.com --scripting"
      echo ""
      _exit 0
    fi

    # We want to make sure that the value for_linode_label is not empty
    if [ -z "${for_linode_label}" ]; then
      # For human text
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --for-linode-label option is required with a value. Please, provide a valid input (eg: --for-linode-label server.domain.com)"
      # For scripting text
      [[ ${scripting} == "true" ]] && echo "error"
      # Exit for human and scripting
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Getting a required linode ID --where-linode-label-is ${for_linode_label} ..."

    linode_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | select(.label == \"${for_linode_label}\") | .id")
    status_handler check --curl-status "$?"

    if [ -n "${linode_id}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: The linode ID --for-linode-label ${for_linode_label} is ${linode_id}"
      [[ ${scripting} == "true" ]] && echo "${linode_id}"
      _exit 0
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode ID is found --where-linode-label-is ${for_linode_label}"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi
  # v1.0
  elif [[ "${action^^}" == +(GET-STATUS|SERVER-STATUS|GET-LINODE-STATUS|GET-RUNNING-STATUS|GET-LINODE-RUNNING-STATUS|GET-SERVER-STATUS) ]]; then
    local linode_status wait_total

    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: ${action}"
      echo "Required option(s): --for-linode-label <linode label>"
      echo "Purpose: This action is used for showing the status of linode based on a given linode label"
      echo "You cannot have the same linode names for all your servers (linode rule). So this action will only return 1 status"
      echo "You can pass the following options to wait for linode status:"
      echo "    --wait-until-linode-status <status>"
      echo "    --max-retries <total time to retry checking linode status>"
      echo "Example 1:"
      echo "  ${SCRIPT_NAME} linode ${action} --for-linode-label sun.sofibox.com"
      echo "Example 2: Wait until status change into offline for 120 times call/second"
      echo "  ${SCRIPT_NAME} linode ${action} --for-linode-label sun.sofibox.com --wait-until-linode-status offline --max-wait 120"
      echo ""
      _exit 0
    fi

    if [ -z "${for_linode_label}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --for-linode-label option is required with a value. Please, provide a valid input (eg: --for-linode-label server.domain.com)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Getting linode status --for-linode-label ${for_linode_label} ..."

    linode_status=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | select(.label == \"${for_linode_label}\") | .status")
    status_handler check --curl-status "$?"

    if [ -n "${wait_until_linode_status}" ]; then
      # Syntax: wait_status_for linode <linode_label>
      #         wait_status_for disk <linode_id> <disk_id>
      wait_status_for linode "${for_linode_label}"
    else
      if [ -n "${linode_status}" ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: The linode status --for-linode-label ${for_linode_label} is ${linode_status} ..."
        [[ ${scripting} == "true" ]] && echo "${linode_status}"
        _exit 0
      else
        # if linode status is other than above or does not exist, it will show this
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the linode status --for-linode-label ${for_linode_label} is empty!"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

    fi
  # v1.0
  elif [[ "${action^^}" == +(RESTART-INTO-RESCUE|BOOT-INTO-RESCUE|REBOOT-TO-RESCUE|RESCUE-REBOOT|REBOOT-RESCUE|BOOT-TO-RESCUE|RESCUE-MODE|FINIX-MODE|REBOOT-TO-FINIX) ]]; then
    # Note there is a known bug in linode rescue mode where you might not be able to get out from the rescue mode faster using API because Finnix recovery OS will prompt you to eject physical disk with your physical hand.
    # When using API, you don't have the ability to manually press ENTER as prompted by the recovery disk to eject disk (also there should be no physical disk exist in linode). I'm not sure why they put this logic there.
    # However, after tested with a time command, the prompt will be gone after 2m6.910s (that is a very long duration for an API call). This bug is explained here and I have provided a workaround there too:
    # https://www.linode.com/community/questions/21319/please-remove-the-disk-eject-question-on-finnix-rescue-disk#answer-82269
    local linode_id disk_volume_letters json_query_data label_name label_type label_disk_vol wait_total disk_volume_provided_count

    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: ${action}"
      echo "Required option(s): --for-linode-label <linode label>"
      echo "Purpose: This action is used to boot linode into rescue mode (the Finnix Recovery mode)"
      echo "Notes:"
      echo "You can optionally mount disks or volumes before starting linode into rescue mode using the following mounting syntax"
      echo "   --dev-sd<letter[a-g]> <disk or volume>:<disk or volume label that must be quoted if it contains space>"
      echo "   example: --dev-sdg disk:OS_DISK  or  --dev-sde \"volume: My volume\""
      echo "   Note that the disk letter can be only use from a-g. The h is reserved for Finnix Recovery"
      echo "You can pass the following options to wait for linode status:"
      echo "    --wait-until-linode-status <status>"
      echo "    --max-retries <total time to retry checking linode status>"
      echo "You can also pass the following option to check for linode busy status first before executing the API"
      echo "    --check-busy-status"
      echo "Example 1:"
      echo "    ${SCRIPT_NAME} linode ${action} --for-linode-label server.domain.com --check-busy-status"
      echo "Example 2:"
      echo "    ${SCRIPT_NAME} linode ${action} --for-linode-label server.domain.com --dev-sda \"disk:a quoted volume label\" --dev-sdb disk:def --dev-sdc \"volume:a label with space\""
      echo ""
      _exit 0
    fi

    # Make sure linode label is not empty
    if [ -z "${for_linode_label}" ]; then
      # For human text
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --for-linode-label option is required with a value. Please, provide a valid input (eg: --for-linode-label server.test.domain.com)"
      # For scripting text
      [[ ${scripting} == "true" ]] && echo "error"
      # Exit for human and scripting
      _exit 1
    fi

    if [ -n "${for_linode_config_label}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the option --for-linode-config-label option is not required for this action"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Getting linode ID --for-linode-label ${for_linode_label} ..."

    linode_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq ".data[] | select(.label == \"${for_linode_label}\") | .id")
    status_handler check --curl-status "$?"

    if [ -z "${linode_id}" ]; then

      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode ID is found --for-linode-label ${for_linode_label}"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    # We check linode status whether it is busy. Note that a linode label (for_linode_label) must be exist first before calling this:
    if [ "${check_for_busy_status}" == true ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, linode is set to check for busy status first"
      # Syntax: check_busy_status_for disk <linode_label>
      #         check_busy-status_for linode <linode_label>
      check_busy_status_for linode "${for_linode_label}"
      check_busy_status_for disk "${for_linode_label}"
    fi

    # Here we build json query data for mounting devices
    json_query_data='{"devices": {}}'

    # The maximum disk and volume letter in linode is h but h is only use for finnix rescue mode so we allow max until the letter g only
    disk_volume_letters="a b c d e f g"
    disk_volume_provided_count=0

    # We loop through all the disk letter and provided options
    for disk_volume_letter in ${disk_volume_letters}; do
      local label_type label_name disk_id volume_id
      typeset -n label_disk_vol="label_devsd${disk_volume_letter}"
      if [ -n "${label_disk_vol}" ]; then

        ((disk_volume_provided_count++))
      fi

      label_type=$(echo "${label_disk_vol}" | awk -F: '{ print $1 }')
      label_name=$(echo "${label_disk_vol}" | awk -F: '{ print $2 }')

      if [ "${label_type}" == "disk" ]; then
        # Note: basically disk_id can generate multiple result based on the disk label found (so, we only take the last record using tail -n 1)
        disk_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances/${linode_id}/disks" | jq -r ".data[] | select(.label == \"${label_name}\") | .id" | tail -n 1)
        status_handler check --curl-status "$?"
        if [ -n "${disk_id}" ]; then
          volume_id=null
        fi
      elif [ "${label_type}" == "volume" ]; then
        # Note: basically volume_id can generate multiple result based on the volume label found (so, we only take the last record using tail -n 1)
        volume_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/volumes" | jq -r ".data[] | select(.label == \"${label_name}\") | .id" | tail -n 1)
        status_handler check --curl-status "$?"
        if [ -n "${volume_id}" ]; then
          disk_id=null
        fi
      else
        continue
      fi

      if [[ -z "${disk_id}" || -z "${volume_id}" ]]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the ${label_type} label name ${label_name} does not exist. Please, make sure that the ${label_type} label name ${label_type} was created first in linode"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

      # construct json mounting options for disks/volumes
      json_query_data="$(
        jq --argjson disk_id "${disk_id}" --argjson volume_id "${volume_id}" --arg disk_volume_letter "${disk_volume_letter}" '
                      .devices |= . + {"sd\($disk_volume_letter)": {$disk_id, $volume_id}}
                    ' <<<"$json_query_data"
      )"

      [[ ${scripting} == "false" ]] && echo ""
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Volume and disk information"
      [[ ${scripting} == "false" ]] && echo "[${caller}]: =========================="
      [[ ${scripting} == "false" ]] && echo "[${caller}]: disk_volume_letter: ${disk_volume_letter}"
      [[ ${scripting} == "false" ]] && echo "[${caller}]: label_disk_vol: ${label_disk_vol}"
      [[ ${scripting} == "false" ]] && echo "[${caller}]: label_type: ${label_type}"
      [[ ${scripting} == "false" ]] && echo "[${caller}]: label_name: ${label_name}"
      [[ ${scripting} == "false" ]] && echo "[${caller}]: disk_id: ${disk_id}"
      [[ ${scripting} == "false" ]] && echo "[${caller}]: volume_id: ${volume_id}"
      [[ ${scripting} == "false" ]] && echo "[${caller}]: =========================="
      [[ ${scripting} == "false" ]] && echo ""

    done

    if [ "${disk_volume_provided_count}" -eq 0 ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, Linode will boot into rescue mode without mounting any disks or volumes"
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, Linode will boot into rescue mode and mount the following options: "
      [[ ${scripting} == "false" ]] && echo "${json_query_data}"
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Putting linode --where-linode-label-is ${for_linode_label} into rescue mode ..."

    response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "Content-Type: application/json" -H "${api_auth_string}" \
      -X POST --data "${json_query_data}" --url "${api_url}/linode/instances/${linode_id}/rescue")
    status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success \
      --error-msg "there was something wrong when trying to reboot linode into rescue mode --for-linode-label ${for_linode_label}" \
      --success-msg "the linode --for-linode-label ${for_linode_label} has been set to reboot into rescue mode"

    if [ -n "${wait_until_linode_status}" ]; then
      # Syntax: wait_status_for linode <linode_label>
      #         wait_status_for disk <linode_id> <disk_id>
      wait_status_for linode "${for_linode_label}"

    fi

  # v1.0
  elif [[ "${action^^}" == +(BOOT-LINODE|START-LINODE|BOOT|START|TURN-ON|TURNON|POWER-ON|POWERON) ]]; then
    local linode_id linode_config_id wait_total

    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: ${action}"
      echo "Required option(s): --for-linode-label <linode label>"
      echo "Purpose: This action is used to start / boot an offline linode. It will not work if the current linode status is online"
      echo "Notes:"
      echo "You can pass an option --shutdown-linode-first to initiate server shutdown before executing the API"
      echo "You can pass the following options to wait for linode status during boot process:"
      echo "    --wait-until-linode-status <status>"
      echo "    --max-retries <total time to retry checking linode status>"
      echo "You can also pass the following option to check for linode busy status first before executing the API"
      echo "    --check-busy-status"
      echo "You may pass an option --for-config-label <config label name> to use config profile when starting linode"
      echo "if no config label is found, it will use the last successful booted config profile"
      echo "Example 1:"
      echo "    ${SCRIPT_NAME} linode ${action} --for-linode-label server.domain.com --shutdown-linode-first"
      echo "Example 2:"
      echo "    ${SCRIPT_NAME} linode ${action} --for-linode-label server.domain.com --for-config-label OS_Config --check-busy-status"
      echo ""
      _exit 0
    fi

    if [ -z "${for_linode_label}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --for-linode-label option required a valid value (eg: --for-linode-label sun.sofibox.com)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Getting a required linode ID --for-linode-label ${for_linode_label} ..."
    linode_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | select(.label == \"${for_linode_label}\") | .id")
    status_handler check --curl-status "$?"

    if [ -z "${linode_id}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode ID is found --for-linode-label ${for_linode_label}"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Getting a required linode config ID --for-linode-config-label ${for_linode_config_label} ..."

    linode_config_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances/${linode_id}/configs" | jq -r ".data[] | select(.label == \"${for_linode_config_label}\") | .id")

    if [ "${check_for_busy_status}" == true ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, linode is set to check for busy status first"
      # Syntax: check_busy_status_for disk <linode_label>
      #         check_busy-status_for linode <linode_label>
      check_busy_status_for linode "${for_linode_label}"
      check_busy_status_for disk "${for_linode_label}"
    fi

    if [[ "${shutdown_linode_first}" == true ]]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, linode is set to be shutdown first"
      # Syntax: shutdown_linode_first <linode label>
      shutdown_linode_first "${for_linode_label}"
    fi

    # If we don't find linode_config_id, it will boot from the last successful profile
    if [ -n "${linode_config_id}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Booting linode ${for_linode_label} ( ${linode_id} ) with the option --where-linode-config-label-is ${for_linode_config_label} ..."
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, no linode config ID is found --for-linode-config-label ${for_linode_config_label}. Booting linode using the last successful config profile ..."
    fi

    response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "Content-Type: application/json" -H "${api_auth_string}" \
      -X POST --url "${api_url}/linode/instances/${linode_id}/boot?config_id=${linode_config_id}")
    status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success --error-msg "there was something wrong when trying to boot linode ${for_linode_label} from offline" --success-msg "the linode ${for_linode_label} has been set to boot from offline"

    if [ -n "${wait_until_linode_status}" ]; then
      # Syntax: wait_status_for linode <linode_label>
      #         wait_status_for disk <linode_id> <disk_id>
      wait_status_for linode "${for_linode_label}"

    fi
  # v1.0

  elif [[ "${action^^}" == +(RESTART-LINODE|REBOOT-LINODE|REBOOT|RESTART) ]]; then
    local linode_id linode_config_id wait_total

    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: ${action}"
      echo "Required option(s): --for-linode-label <linode label>"
      echo "Purpose: This action is used to restart / reboot a linode"
      echo "Notes:"
      echo "You can pass the following options to wait for linode status during reboot process:"
      echo "    --wait-until-linode-status <status>"
      echo "    --max-retries <total time to retry checking linode status>"
      echo "You can also pass the following option to check for linode busy status first before executing the API"
      echo "    --check-busy-status"
      echo "You may pass an option --for-config-label <config label name> to use config profile when starting linode"
      echo "if no config label is found, it will use the last successful booted config profile"
      echo "Example 1:"
      echo "    ${SCRIPT_NAME} linode ${action} --for-linode-label server.domain.com --shutdown-linode-first"
      echo "Example 2:"
      echo "    ${SCRIPT_NAME} linode ${action} --for-linode-label server.domain.com --for-config-label OS_Config --check-busy-status"
      echo ""
      _exit 0
    fi

    if [ -z "${for_linode_label}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --for-linode-label option required a valid value (eg: --for-linode-label sun.sofibox.com)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Getting a required linode ID  --for-linode-label ${for_linode_label} ..."
    linode_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | select(.label == \"${for_linode_label}\") | .id")
    status_handler check --curl-status "$?"

    if [ -z "${linode_id}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode ID is found --for-linode-label ${for_linode_label}"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Getting a required linode config ID --for-linode-config-label ${for_linode_config_label} ..."

    linode_config_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances/${linode_id}/configs" | jq -r ".data[] | select(.label == \"${for_linode_config_label}\") | .id")

    if [ "${check_for_busy_status}" == true ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, linode is set to check for busy status first"
      # Syntax: check_busy_status_for disk <linode_label>
      #         check_busy-status_for linode <linode_label>
      check_busy_status_for linode "${for_linode_label}"
      check_busy_status_for disk "${for_linode_label}"
    fi

    # If we don't find linode_config_id, it will boot from the last successful profile
    if [ -n "${linode_config_id}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}->${action}]: Rebooting linode ${for_linode_label} ( ${linode_id} ) with the option --where-linode-config-label-is ${for_linode_config_label} ..."
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}->${action}]: Notice, no linode config ID is found --for-linode-config-label ${for_linode_config_label}. Rebooting linode using the last successful config profile ..."
    fi

    response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "Content-Type: application/json" -H "${api_auth_string}" \
      -X POST --url "${api_url}/linode/instances/${linode_id}/reboot?config_id=${linode_config_id}")
    status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success --error-msg "there was something wrong when trying to reboot linode ${for_linode_label}" --success-msg "the linode ${for_linode_label} has been set to reboot"

    if [ -n "${wait_until_linode_status}" ]; then
      # Syntax: wait_status_for linode <linode_label>
      #         wait_status_for disk <linode_id> <disk_id>
      wait_status_for linode "${for_linode_label}"

    fi
  # v1.0
  elif [[ "${action^^}" == +(SHUTDOWN-LINODE|POWEROFF-LINODE|TURNOFF-LINODE|SHUTDOWN|POWEROFF|TURNOFF|BYE) ]]; then
    local linode_id wait_total

    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: ${action}"
      echo "Required option(s): --for-linode-label <linode label>"
      echo "Purpose: This action is used to shutdown / turn off a linode"
      echo "Notes:"
      echo "When linode is already shut down, triggering this action will shut it again for no reason (the linode logic)"
      echo "You can pass the following options to wait for linode status during shut down process:"
      echo "    --wait-until-linode-status <status>"
      echo "    --max-retries <total time to retry checking linode status>"
      echo "You can also pass the following option to check for linode busy status first before executing the API"
      echo "    --check-busy-status"
      echo "Example 1:"
      echo "    ${SCRIPT_NAME} linode ${action} --for-linode-label server.domain.com --check-busy-status --wait-until-linode-status offline"
      echo ""
      _exit 0
    fi

    if [ -z "${for_linode_label}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --for-linode-label option required a valid value (eg: --for-linode-label sun.sofibox.com)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Getting a required linode ID  --for-linode-label ${for_linode_label} ..."
    linode_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | select(.label == \"${for_linode_label}\") | .id")
    status_handler check --curl-status "$?"

    if [ -z "${linode_id}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode ID is found --for-linode-label ${for_linode_label}"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    if [ "${check_for_busy_status}" == true ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, linode is set to check for busy status first"
      # Syntax: check_busy_status_for disk <linode_label>
      #         check_busy-status_for linode <linode_label>
      check_busy_status_for linode "${for_linode_label}"
      check_busy_status_for disk "${for_linode_label}"
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Shutting down linode ${for_linode_label} ( ${linode_id} ) ..."

    response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "Content-Type: application/json" -H "${api_auth_string}" \
      -X POST --url "${api_url}/linode/instances/${linode_id}/shutdown")
    status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success --error-msg "there was something wrong when trying to shutdown linode ${for_linode_label}" --success-msg "the linode ${for_linode_label} has been set to shutdown"

    if [ -n "${wait_until_linode_status}" ]; then
      # Syntax: wait_status_for linode <linode_label>
      #         wait_status_for disk <linode_id> <disk_id>
      wait_status_for linode "${for_linode_label}"

    fi
    # v1.0
  elif [[ "${action^^}" == +(CREATE-DISK|ADD-DISK) ]]; then
    local linode_id disk_status linode_status json_query_data

    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: ${action}"
      echo "Required option(s):"
      echo "  --for-linode-label <linode label>"
      echo "  --disk-label <disk label>"
      echo "  --disk-filetype <disk file type>"
      echo "  --disk-size <disk size>"
      echo "Purpose: This action is used to create / add disk in a linode"
      echo "Notes:"
      echo "The create-disk API allow to create disk when linode is running. You may want to use the option --shutdown-linode-first for a peace of mind"
      echo "You can pass the following options to wait for disk status during creation process:"
      echo "    --wait-until-disk-status <status>"
      echo "    --max-retries <total time to retry checking linode status>"
      echo "You can also pass the following option to check for linode busy status first before executing the API"
      echo "    --check-busy-status"
      echo "You can have the same name for disk labels but it is not recommended to do that. To allow duplicated label entries use the option --allow-duplicated-entries"
      echo "Example 1:"
      echo "    ${SCRIPT_NAME} linode ${action} --for-linode-label sun.sofibox.com --disk-label abc_disk --linode-disk-filetype raw --linode-disk-size 1MB --wait-until-disk-status ready"
      echo "Example 2:"
      echo "    ${SCRIPT_NAME} linode ${action} --for-label sun.sofibox.com --disk-label 123 --disk-filetype raw --disk-size 1GB --allow-duplicate-entries --wait-until-disk-status online --check-for-busy-status --max-retries 10"
      echo ""
      _exit 0
    fi

    json_query_data='{}'

    if ! is_valid not-empty-string "${for_linode_label}"; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --for-linode-label option required a valid value (eg: --for-linode-label sun.sofibox.com)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    if is_valid not-empty-string "${linode_disk_label}"; then

      json_query_data=$(jq --arg linode_disk_label "${linode_disk_label}" '.label |= $linode_disk_label' <<<"${json_query_data}")
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --linode-disk-label option required a valid value (eg: --linode-disk-label OS_Disk)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    if is_valid valid-linode-disk-filetype "${linode_disk_filetype}"; then

      json_query_data=$(jq --arg linode_disk_filetype "${linode_disk_filetype}" '.filesystem |= $linode_disk_filetype' <<<"${json_query_data}")
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --linode-disk-filetype option required a valid value (eg: --linode-disk-filetype raw)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    if is_valid not-empty-string "${linode_disk_size}" && is_valid integer "${linode_disk_size}"; then
      json_query_data=$(jq --argjson linode_disk_size "${linode_disk_size}" '.size |= $linode_disk_size' <<<"${json_query_data}")
    else

      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --linode-disk-size option required a valid value (eg: --linode-disk-size 20GB)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    # We need to shutdown linode first in order to create disk if this option is given. This shutdown process is in loop without passing option --until-linode-status
    if [[ "${shutdown_linode_first}" == true ]]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, linode is set to be shutdown first"
      # Syntax: shutdown_linode_first <linode label>
      shutdown_linode_first "${for_linode_label}"
    fi

    # Note this check must be performed before calling any APIs and after we passed some required options.
    if [ "${check_for_busy_status}" == true ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, linode is set to check for busy status first"
      # Syntax: check_busy_status_for disk <linode_label>
      #         check_busy-status_for linode <linode_label>

      # We must check both linode and disk
      check_busy_status_for linode "${for_linode_label}"
      check_busy_status_for disk "${for_linode_label}"

    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Getting a required linode ID for --for-linode-label ${for_linode_label} ..."
    linode_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | select(.label == \"${for_linode_label}\") | .id")
    status_handler check --curl-status "$?"

    if [ -z "${linode_id}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode ID is found for --linode-label ${for_linode_label}"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    if [[ ${allow_duplicate_entries} == false ]]; then
      local existing_label

      [[ ${scripting} == "false" ]] && echo "[${caller}]: Checking for existing entry of --linode-disk-label ${linode_disk_label} ..."

      existing_label=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances/${linode_id}/disks?page_size=${linode_max_page_size}" | jq -r ".data[] | select(.label == \"${linode_disk_label}\") | .label" | tail -n 1)
      status_handler check --curl-status "$?"

      if [[ "${existing_label}" == "${linode_disk_label}" ]]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, there is already an existing linode disk label --linode-disk-label ${linode_disk_label} in linode. In order to create a duplicate entry, use the option --allow-duplicate-entries"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1

      fi
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, the option --allow-duplicate-entries is set. Duplicated disk label is allowed to be created"
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Creating a new linode disk with --linode-disk-label ${linode_disk_label} ..."

    [[ ${scripting} == "false" ]] && echo "[${caller}]: json_query_data: "

    [[ ${scripting} == "false" ]] && echo "${json_query_data}"

    response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "Content-Type: application/json" -H "${api_auth_string}" \
      -X POST --data "${json_query_data}" --url "${api_url}/linode/instances/${linode_id}/disks")
    status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success --error-msg "there was something wrong when trying to issue create linode disk" --success-msg "the linode disk has been set to be created"

    disk_id=$(jq -r '.id' "${RESPONSE_FILE}")

    if [ -n "${wait_until_disk_status}" ]; then
      # Syntax: wait_status_for disk <linode_id> <disk_id> <disk_label>
      # Variable wait_until_disk_status is passed in option
      wait_status_for disk "${linode_id}" "${disk_id}" "${linode_disk_label}"
    fi

    # To remove specific disk (can be one or more based on the label): maxipi linode delete-disk --linode-label test.server.com --linode-disk-label "OS_Disk"

  # v1.0
  elif [[ "${action^^}" == +(DELETE-DISK|REMOVE-DISK|DELETE-DISKS|REMOVE-DISKS) ]]; then
    local linode_id disk_ids disk_ids_count disk_status disk_count disk_id

    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: delete-disks / delete-disk"
      echo "Required option(s):"
      echo "  --for-linode-label <linode label>"
      echo "  --for-disk-label <disk label> (REQUIRED ONLY if action does not end with postfix -s)"
      echo "  --shutdown-linode-first option is required only if linode is online. You cannot delete disk when linode is online status (linode rule)"
      echo "Purpose: This action is used to delete / remove disk(s) in a linode"
      echo "Notes:"
      echo "The remove-disk(s) action does not allow disk to be removed when linode is running. You must use the option --shutdown-linode-first if linode is online"
      echo "When deleting is in progress, you will be shown the current disk status until it is completely gone or has error"
      echo "You might want to use the option --first-record to only delete the first record or --last-record to delete only the last record"
      echo "You can also pass the following option to check for linode busy status first before executing the API"
      echo "    --check-busy-status"
      echo "You can delete multiple disks with one command that have the same label name but you will be prompt before deleting multiple disks"
      echo "Use the action ending with postfix -s to search for all existing disks or a given linode label name"
      echo "If an action given is ending with postfix -s eg: delete-disks or remove-disks (we search for all disks to be deleted), but we can still can pass --first-record or --last-record options"
      echo "Warning, if you supply the --scripting option, you will not have prompt for this action. This may delete multiple disks without prompt (use at your own risk)"
      echo "Example 1:"
      echo "    ${SCRIPT_NAME} linode delete-disk --for-linode-label sun.sofibox.com --where-disk-label-is abc_disk --shutdown-linode-first"
      echo "Example 2:"
      echo "    ${SCRIPT_NAME} linode delete-disks --for-linode-label sun.sofibox.com --shutdown-linode-first --last-record"
      echo "Example 3 (you will not have prompt if you pass the option --last-record or --first-record or --scripting or the config count is 1):"
      echo "    ${SCRIPT_NAME} linode delete-disks --where-linode-label-is sun.sofibox.com --last-record"
      echo "Example 4 (this will delete all disks with a prompt)"
      echo "    ${SCRIPT_NAME} linode delete-disks --for-linode-label sun.sofibox.com"
      echo "Example 5 (this will delete all disks without prompt - to abort the deletion process press CTRL + C)"
      echo "    ${SCRIPT_NAME} linode delete-disks --for-linode-label sun.sofibox.com --scripting"
      echo ""
      _exit 0
    fi

    if ! is_valid not-empty-string "${for_linode_label}"; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --for-linode-label option required a valid value (eg: --for-linode-label sun.sofibox.com)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Getting a required linode ID --for-linode-label ${for_linode_label} ..."

    linode_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | select(.label == \"${for_linode_label}\") | .id")
    status_handler check --curl-status "$?"

    if [ -z "${linode_id}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode ID is found --for-linode-label ${for_linode_label}"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    if [[ "${action^^}" == +(DELETE-DISKS|REMOVE-DISKS) ]]; then

      [[ ${scripting} == "false" ]] && echo "[${caller}]: Searching all linode disks --where-linode-label-is ${for_linode_label} ..."

      disk_ids=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances/${linode_id}/disks?page_size=${linode_max_page_size}" | jq -r ".data[] | .id")
      status_handler check --curl-status "$?"

      if [ -z "${disk_ids}" ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode disk ID is found --for-linode-label ${for_linode_label}"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
    else # delete-disk or remove-disk
      if ! is_valid not-empty-string "${for_linode_disk_label}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the action ${action} (without a postfix -s) require a valid value --for-disk-label to search existing disk (eg: --for-disk-label OS_Disk)"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

      [[ ${scripting} == "false" ]] && echo "[${caller}]: Searching linode disk(s) --for-linode-label ${for_linode_label} --where-disk-label-is ${for_linode_disk_label} ..."

      disk_ids=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances/${linode_id}/disks?page_size=${linode_max_page_size}" | jq -r ".data[] | select(.label == \"${for_linode_disk_label}\") | .id")

      if [ -z "${disk_ids}" ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode disk is found --for-linode-label ${for_linode_label} --where-disk-label-is ${for_linode_disk_label}"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
    fi

    if [[ "${shutdown_linode_first}" == true ]]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, linode is set to be shutdown first"
      # Syntax: shutdown_linode_first <linode label>
      shutdown_linode_first "${for_linode_label}"
    fi

    if [ "${check_for_busy_status}" == true ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, linode is set to check for busy status first"
      # Syntax: check_busy_status_for disk <linode_label>
      #         check_busy-status_for linode <linode_label>

      check_busy_status_for linode "${for_linode_label}"
      check_busy_status_for disk "${for_linode_label}"
    fi

    # If the option --first-record or --last-record is there, we filter this to only use one record
    if [ "${first_record}" == true ]; then
      disk_ids=$(echo "${disk_ids}" | head -n1)
      [[ ${scripting} == "false" ]] && echo "[${caller}]: List of Disk ID selected (first record): "
    elif [ "${last_record}" == true ]; then
      disk_ids=$(echo "${disk_ids}" | tail -n1)
      [[ ${scripting} == "false" ]] && echo "[${caller}]: List of Disk ID selected (last record): "
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: List of Disk ID(s) selected: "
    fi

    disk_ids_count=$(echo "${disk_ids}" | wc -w)

    [[ ${scripting} == "false" ]] && echo "${disk_ids}" | tr -s '\n' ' '
    [[ ${scripting} == "false" ]] && echo ""

    if [[ "${disk_ids_count}" -gt 1 && "${without_prompt}" == false ]]; then
      [[ ${scripting} == "false" ]] && _confirm "[${caller}->input]: Warning, found ${disk_ids_count} disk records. Do you want to delete them?" n
    fi

    disk_count=0

    for disk_id in ${disk_ids[*]}; do
      local disk_id response_code

      ((disk_count++))

      # This is just for obtaining the disk label based on a given ID (for display purpose)
      disk_name=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances/${linode_id}/disks?page_size=${linode_max_page_size}" | jq -r ".data[] | select(.id == ${disk_id}) | .label")
      status_handler check --curl-status "$?"

      [[ ${scripting} == "false" ]] && echo "[${caller}]: Deleting linode disk ${disk_name} ( ${disk_id} ) ... ${disk_count} / ${disk_ids_count}"

      response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "${api_auth_string}" -X DELETE --url "${api_url}/linode/instances/${linode_id}/disks/${disk_id}")
      status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success \
        --error-msg "there was something wrong when deleting the disk name ${disk_name}" \
        --success-msg "the disk name ${disk_name} has been set to be deleted"

      # Must check deletion process for multiple disk deletion

      [[ ${scripting} == "false" ]] && echo "[${caller}]: Checking disk deletion status for ${disk_name} ( ${disk_id} ) ..."
      while :; do

        disk_status=$(curl -s -H "Content-Type: application/json" -H "${api_auth_string}" --url "${api_url}/linode/instances/${linode_id}/disks/${disk_id}" | jq -r ".status")
        status_handler check --curl-status "$?"

        if [[ -z "${disk_status}" || "${disk_status}" == null ]]; then
          # If disk_status is empty meaning that it has been deleted!
          [[ ${scripting} == "false" ]] && echo "[${caller}]: Success, the linode --for-disk-label ${for_linode_disk_label} ( ${disk_id} ) has been deleted!"
          break
        elif [[ ${disk_status} == "deleting" || "${disk_status}" == "ready" ]]; then
          :
          # List of status that we ignore we put here and we don't print the output
        else
          [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, unknown linode disk status --for-disk-label ${for_linode_disk_label}: ${disk_status}"
          [[ ${scripting} == "true" ]] && echo "error"
          _exit 1
        fi
      done
    done
    # v1.0
  elif [[ "${action^^}" == +(CREATE-CONFIG|ADD-CONFIG) ]]; then

    local linode_id label_type label_name label_disk_vol disk_volume_provided_count json_query_data
    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: ${action}"
      echo "Required option(s):"
      echo "   --for-linode-label <linode_label>"
      echo "   --config-label <config_label>"
      echo "  AT LEAST ONE mounting disk / volume using the following options syntax:"
      echo "  --dev-sd[a-h] <disk or volume>:<disk or volume name> | --dev-sdc disk:MyDisk"
      echo "Purpose: This action is used to delete / remove disk(s) in a linode"
      echo "Notes:"
      echo "You can have the same name for config labels but it is not recommended to do that. To allow duplicated label entries use the option --allow-duplicated-entries"
      echo "Example 1:"
      echo "   ${SCRIPT_NAME} linode create-config --for-linode-label sun.sofibox.com --config-label abc_config --allow-duplicated-entries --dev-sda disk:Boot_Disk --dev-sde volume:MyVol"
      echo "Example 2 (other optional configs):"
      echo "   ${SCRIPT_NAME} linode create-config --for-label sun.sofibox.com --linode-config-label Boot_config --linode-config-comment \"The installer boot configuration\" --linode-config-virtual-mode paravirt \\"
      echo "            --linode-config-kernel linode/direct-disk --linode-config-runlevel default --linode-config-memory-limit 4096 --linode-config-rootdev /dev/sda \\"
      echo "            --linode-config-enable-distro-helper --linode-config-disable-update_db --linode-config-dep-helper --linode-config-automount-devtmpfs --linode-config-autoconf-network \\"
      echo "            --dev-sda disk:Boot_Disk --dev-sdb disk:OS_Disk"
      echo ""
      _exit 0
    fi

    if ! is_valid not-empty-string "${for_linode_label}"; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --for-linode-label option required a valid value (eg: --for-linode-label sun.sofibox.com)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    json_query_data='{}'

    if is_valid not-empty-string "${linode_config_label}"; then
      json_query_data=$(jq --arg linode_config_label "${linode_config_label}" '.label |= $linode_config_label' <<<"${json_query_data}")
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --config-label ${linode_config_label} is not valid (empty string)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Getting a required linode ID --for-linode-label ${for_linode_label} ..."

    linode_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | select(.label == \"${for_linode_label}\") | .id")
    status_handler check --curl-status "$?"

    if [ -z "${linode_id}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode ID is found --for-linode-label ${for_linode_label}"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    if [[ ${allow_duplicate_entries} == false ]]; then
      local existing_label

      [[ ${scripting} == "false" ]] && echo "[${caller}]: Checking for existing entry of --config-label ${linode_config_label} ..."

      existing_label=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances/${linode_id}/configs?page_size=${linode_max_page_size}" | jq -r ".data[] | select(.label == \"${linode_config_label}\") | .label" | tail -n 1)

      if [[ "${existing_label}" == "${linode_config_label}" ]]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, there is already an existing linode config label --config-label ${linode_config_label} in linode. In order to create a duplicate entry, use the option --allow-duplicate-entries"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1

      fi
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, the option --allow-duplicate-entries is set. Hence, duplicated config label is allowed to be created"
    fi

    if [ -n "${linode_config_kernel}" ]; then
      json_query_data=$(jq --arg linode_config_kernel "${linode_config_kernel}" '.kernel |= $linode_config_kernel' <<<"${json_query_data}")
    fi

    if [ -n "${linode_config_comments}" ]; then
      json_query_data=$(jq --arg linode_config_comments "${linode_config_comments}" '.comments |= $linode_config_comments' <<<"${json_query_data}")
    fi

    if [ -n "${linode_config_memory_limit}" ]; then
      json_query_data=$(jq --argjson linode_config_memory_limit "${linode_config_memory_limit}" '.memory_limit |= $linode_config_memory_limit' <<<"${json_query_data}")
    fi

    if [ -n "${linode_config_runlevel}" ]; then
      json_query_data=$(jq --arg linode_config_runlevel "${linode_config_runlevel}" '.run_level |= $linode_config_runlevel' <<<"${json_query_data}")
    fi

    if [ -n "${linode_config_virtual_mode}" ]; then
      json_query_data=$(jq --arg linode_config_virtual_mode "${linode_config_virtual_mode}" '.virt_mode |= $linode_config_virtual_mode' <<<"${json_query_data}")
    fi
    # This is for linode generic configs

    if [ -n "${linode_config_rootdev}" ]; then
      json_query_data=$(jq --arg linode_config_rootdev "${linode_config_rootdev}" '.root_device |= $linode_config_rootdev' <<<"${json_query_data}")
    fi

    # This is for linode helpers
    json_query_data="$(
      jq --argjson linode_config_disable_update_db "${linode_config_disable_update_db}" --argjson linode_config_enable_distro_helper "${linode_config_enable_distro_helper}" \
        --argjson linode_config_enable_dep_helper "${linode_config_enable_dep_helper}" --argjson linode_config_automount_devtmpfs "${linode_config_automount_devtmpfs}" \
        --argjson linode_config_autoconf_network "${linode_config_autoconf_network}" '
                .helpers |= . + {"updatedb_disabled": $linode_config_disable_update_db, "distro": $linode_config_enable_distro_helper, "modules_dep": $linode_config_enable_dep_helper, "devtmpfs_automount": $linode_config_automount_devtmpfs, "network": $linode_config_autoconf_network}
              ' <<<"$json_query_data"
    )"

    # This is for disk mounting options. The maximum disk and volume letter in linode is h but h is only use for finnix rescue mode
    disk_volume_letters="a b c d e f g"

    disk_volume_provided_count=0

    for disk_volume_letter in ${disk_volume_letters}; do
      typeset -n label_disk_vol="label_devsd${disk_volume_letter}"

      if [ -n "${label_disk_vol}" ]; then
        ((disk_volume_provided_count++))
      fi

      label_type=$(echo "${label_disk_vol}" | awk -F: '{ print $1 }')
      label_name=$(echo "${label_disk_vol}" | awk -F: '{ print $2 }')

      if [ "${label_type}" == "disk" ]; then
        # tail -n 1 means only refer to the last disk_id because if labels have the same name we dont want to use the others
        disk_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances/${linode_id}/disks" | jq -r ".data[] | select(.label == \"${label_name}\") | .id" | tail -n1)
        status_handler check --curl-status "$?"
        if [ -n "${disk_id}" ]; then
          volume_id=null
        fi
      elif [ "${label_type}" == "volume" ]; then
        # tail -n 1 means only refer to the last disk_id because if labels have the same name we dont want to use the others
        volume_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/volumes" | jq -r ".data[] | select(.label == \"${label_name}\") | .id" | tail -n1)
        status_handler check --curl-status "$?"
        if [ -n "${volume_id}" ]; then
          disk_id=null
        fi
      else
        continue
      fi

      if [[ -z "${disk_id}" || -z "${volume_id}" ]]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the ${label_type} label ${label_name} does not exist. Please, make sure that the ${label_type} label ${label_name} was created first in linode"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

      json_query_data="$(
        jq --argjson disk_id "${disk_id}" --argjson volume_id "${volume_id}" --arg disk_volume_letter "${disk_volume_letter}" '
                .devices |= . + {"sd\($disk_volume_letter)": {$disk_id, $volume_id}}
              ' <<<"$json_query_data"
      )"

      [[ ${scripting} == "false" ]] && echo ""
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Volume and disk information"
      [[ ${scripting} == "false" ]] && echo "[${caller}]: =========================="
      [[ ${scripting} == "false" ]] && echo "[${caller}]: disk_volume_letter_count: ${disk_volume_provided_count}"
      [[ ${scripting} == "false" ]] && echo "[${caller}]: disk_volume_letter: ${disk_volume_letter}"
      [[ ${scripting} == "false" ]] && echo "[${caller}]: label_disk_vol: ${label_disk_vol}"
      [[ ${scripting} == "false" ]] && echo "[${caller}]: label_type: ${label_type}"
      [[ ${scripting} == "false" ]] && echo "[${caller}]: label_name: ${label_name}"
      [[ ${scripting} == "false" ]] && echo "[${caller}]: disk_id: ${disk_id}"
      [[ ${scripting} == "false" ]] && echo "[${caller}]: volume_id: ${volume_id}"
      [[ ${scripting} == "false" ]] && echo "[${caller}]: =========================="
      [[ ${scripting} == "false" ]] && echo ""
    done

    if [ "${disk_volume_provided_count}" -eq 0 ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, device option is blank. Linode config required at least one device to be mounted (eg: --dev-sda disk:OS_Disk)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, Linode config will be created and mount with the following options: "
      [[ ${scripting} == "false" ]] && echo "${json_query_data}"
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Creating a new linode config with --disk-label ${linode_config_label} ..."

    response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "Content-Type: application/json" -H "${api_auth_string}" \
      -X POST --data "${json_query_data}" --url "${api_url}/linode/instances/${linode_id}/configs")
    status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success --success-msg "the linode config profile for --config-label ${linode_config_label} has been created" --error-msg "there was something wrong when trying to create linode config profile for --config-label ${linode_config_label}"
    # v1.0
  elif [[ "${action^^}" == +(DELETE-CONFIGS|REMOVE-CONFIGS|DELETE-CONFIG|REMOVE-CONFIG) ]]; then
    local linode_id config_ids config_ids_count config_count config_id

    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: delete-configs / delete-config"
      echo "Required option(s):"
      echo "  --for-linode-label <linode label>"
      echo "  --config-label <config label> (REQUIRED ONLY if the action does not end with postfix -s)"
      echo "Purpose: This action is used to delete / remove config(s) in a linode"
      echo "Notes:"
      echo "When deleting is in progress, you will be shown the current config status until it is completely gone or has an error"
      echo "You might want to use the option --first-record to delete only the first record or --last-record to delete only the last record"
      echo "When deleting a config profile, we do not need to check for busy status. If linode or disk status is busy, we can still delete it without an issue"
      echo "You can delete multiple configs with one command that have the same label name but you will be prompted before deleting multiple configs"
      echo "Use the action ending with postfix -s to search for all existing configs for a given linode label name"
      echo "If an action given is ending with postfix -s eg: delete-configs or remove-configs (we search for all configs to be deleted), we can still pass --first-record or --last-record options"
      echo "Warning, if you supply the --scripting option, you will not have a prompt for this action. This may delete multiple configs without prompt (use at your own risk)"
      echo "Example 1: (delete a specific config)"
      echo "    ${SCRIPT_NAME} linode delete-config --for-linode-label sun.sofibox.com --where-config-label-is abc_config"
      echo "Example 2 (this might contain 1 or more results, so we can use --last-record or --first-record):"
      echo "    ${SCRIPT_NAME} linode delete-config --for-linode-label sun.sofibox.com --for-config-label abc_config --last-record"
      echo "Example 3 (you will not have a prompt if you pass the option --last-record or --first-record or --scripting or the config count is 1):"
      echo "    ${SCRIPT_NAME} linode delete-configs --for-linode-label sun.sofibox.com --last-record"
      echo "Example 4 (this will delete all configs with a prompt)"
      echo "    ${SCRIPT_NAME} linode delete-configs --for-linode-label sun.sofibox.com"
      echo "Example 5 (this will delete all configs without a prompt - to abort the deletion process press CTRL + C)"
      echo "    ${SCRIPT_NAME} linode delete-configs --for-linode-label sun.sofibox.com --scripting"
      echo ""
      _exit 0
    fi

    if ! is_valid not-empty-string "${for_linode_label}"; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --for-linode-label option required a valid value (eg: --for-linode-label sun.sofibox.com)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Getting a required linode ID --for-linode-label ${for_linode_label} ..."

    linode_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | select(.label == \"${for_linode_label}\") | .id")
    status_handler check --curl-status "$?"

    if [ -z "${linode_id}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode ID is found --for-linode-label ${for_linode_label}"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    if [[ "${action^^}" == +(DELETE-CONFIGS|REMOVE-CONFIGS) ]]; then

      [[ ${scripting} == "false" ]] && echo "[${caller}]: Searching all configs in linode --where-linode-label-is ${for_linode_label} ..."

      config_ids=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances/${linode_id}/configs?page_size=${linode_max_page_size}" | jq -r ".data[] | .id")
      status_handler check --curl-status "$?"

      if [ -z "${config_ids}" ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode config ID is found --for-linode-label ${for_linode_label}"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
    else # delete-config or remove-config
      if ! is_valid not-empty-string "${for_linode_config_label}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the action ${action} (without a postfix -s) require a valid value --for-config-label to search existing config (eg: --for-config-label OS_Config)"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

      [[ ${scripting} == "false" ]] && echo "[${caller}]: Searching linode config(s) --for-linode-label ${for_linode_label} --where-config-label-is ${for_linode_config_label} ..."

      config_ids=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances/${linode_id}/configs?page_size=${linode_max_page_size}" | jq -r ".data[] | select(.label == \"${for_linode_config_label}\") | .id")
      status_handler check --curl-status "$?"

      if [ -z "${config_ids}" ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode config is found --for-linode-label ${for_linode_label} --where-config-label-is ${for_linode_config_label}"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

    fi

    # If the option --first-record or --last-record is there, we filter this to only use one record
    if [ "${first_record}" == true ]; then
      config_ids=$(echo "${config_ids}" | head -n1)
      [[ ${scripting} == "false" ]] && echo "[${caller}]: List of config ID selected (first record): "
    elif [ "${last_record}" == true ]; then
      config_ids=$(echo "${config_ids}" | tail -n1)
      [[ ${scripting} == "false" ]] && echo "[${caller}]: List of config ID selected (last record): "
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: List of config ID(s) selected: "
    fi

    config_ids_count=$(echo "${config_ids}" | wc -w)

    [[ ${scripting} == "false" ]] && echo "${config_ids}" | tr -s '\n' ' '
    [[ ${scripting} == "false" ]] && echo ""

    if [[ "${config_ids_count}" -gt 1 && "${without_prompt}" == false ]]; then
      [[ ${scripting} == "false" ]] && _confirm "[${caller}->input]: Warning, found ${config_ids_count} config records. Do you want to delete them?" n
    fi

    config_count=0

    for config_id in ${config_ids[*]}; do
      local config_id response_code
      ((config_count++))

      # This is just for obtaining the config label based on a given ID (for display purpose)
      config_name=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances/${linode_id}/configs?page_size=${linode_max_page_size}" | jq -r ".data[] | select(.id == ${config_id}) | .label")
      status_handler check --curl-status "$?"

      [[ ${scripting} == "false" ]] && echo "[${caller}]: Deleting linode config ${config_name} ( ${config_id} ) ... ${config_count} / ${config_ids_count}"

      response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "${api_auth_string}" -X DELETE --url "${api_url}/linode/instances/${linode_id}/configs/${config_id}")
      status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success \
        --error-msg "there was something wrong when deleting the config name ${config_name}" \
        --success-msg "the config name ${config_name} has been deleted"
    done

    # v1.0
  elif [[ "${action^^}" == +(DOMAIN-GET-ID|GET-DOMAIN-ID|DOMAIN-ID) ]]; then
    local domain_id

    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: ${action}"
      echo "Required option(s):"
      echo "  --for-domain <domain name> or --where-domain-is <domain name>"
      echo "Purpose: This action is used to get an ID for a given domain name"
      echo "Notes:"
      echo "-"
      echo "Example 1:"
      echo "    ${SCRIPT_NAME} linode ${action} --for-domain sofibox.com"
      echo "Example 2: (use with --scripting option)"
      echo "    ${SCRIPT_NAME} linode ${action} --for-domain sofibox.com --scripting"
      echo ""
      _exit 0
    fi

    if [ -z "${for_domain_name}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --for-domain option is required with a value. Please, provide a valid input (eg: --for-domain domain.com)"
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Getting a required domain ID --for-domain ${for_domain_name} ..."

    domain_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/domains?page_size=${linode_max_page_size}" | jq ".data[] | select(.domain == \"${for_domain_name}\") | .id")
    status_handler check --curl-status "$?"

    if [ -n "${domain_id}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: The domain ID --for-domain ${for_domain_name} is ${domain_id}"
      [[ ${scripting} == "true" ]] && echo "${domain_id}"
      _exit 0
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no domain ID is found --for-domain ${for_domain_name}"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

  # v1.0
  # THis is bookmarked TODO
  elif [[ "${action^^}" == +(CREATE-DOMAIN|DOMAIN-CREATE|ADD-DOMAIN|DOMAIN-ADD) ]]; then
    local json_query_data
    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: ${action}"
      echo "Required option(s):"
      echo "  --domain-name <domain_name>"
      echo "  --domain-type <domain_type>"
      echo "  --domain-master-ips <1 or more ip_addresses separated by a space> (REQUIRED only if --domain-type is slave)"
      echo "  --domain-email <domain_email> (REQUIRED only if --domain-type is master)"
      echo "Purpose: This action is used to create / add a domain in linode"
      echo "Notes:"
      echo "The option --domain-email is required by linode if the --domain-type is set to master. However, if you don't use this option it will have a default email value with the following syntax: webmaster@<domain_name>"
      echo "You cannot create a domain name with the same label name if it is already exist in linode. If a domain is already exist, you can use an option --rebuild or --force to recreate the domain from scratch"
      echo "You will not be able to create some other domains that are reserved in linode domain management (eg: microsoft.com, apple.com)"
      echo "Example 1 (create a master domain by just specifying a --domain-name option):"
      echo "    ${SCRIPT_NAME} linode ${action} --domain-name sofibox.com"
      echo "Example 2 (create a master domain by specifying the full options):"
      echo "    ${SCRIPT_NAME} linode ${action} --domain-name sofibox.com --domain-type master --domain-email webmaster@sofibox.com --domain-ttl 30 --domain-status active"
      echo "Example 3: (use the option --rebuild to recreate the same domain name if it already exist)"
      echo "    ${SCRIPT_NAME} linode ${action} --domain-name sofibox.com --rebuild"
      echo "Example 4: (you can disable a new domain after being created with the following commands)"
      echo "    ${SCRIPT_NAME} linode ${action} --domain-name sofibox.com --domain-status disabled"
      echo "Example 5: (create a slave domain with 1 domain master IP)"
      echo "    ${SCRIPT_NAME} linode ${action} --domain-name sofibox.com --domain-type slave --domain-master-ips 1.2.3.4"
      echo "Example 6: (create a slave domain with multiple domain master IPs)"
      echo "    ${SCRIPT_NAME} linode ${action} --domain-name sofibox.com --domain-type slave --domain-master-ips \"1.2.3.4 1.2.3.4 ::1\""
      echo ""
      _exit 0
    fi

    json_query_data='{}'

    # The domain name is required
    if is_valid domain "${domain_name}"; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --domain-name ${domain_name} is a valid FQDN"
      json_query_data=$(jq --arg domain "${domain_name}" '.domain |= $domain' <<<"${json_query_data}")
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --domain-name ${domain_name} is not a valid FQDN"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    # These are the other options that are required to create a domain in linode. You can ignore these options for default values:

    # Validate domain_type
    if [ -n "${domain_type}" ]; then
      if is_valid domain_type "${domain_type}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --domain-type ${domain_type} is a valid"
        json_query_data=$(jq --arg type "${domain_type}" '.type |= $type' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --domain-type ${domain_type} is not a valid"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, the option --domain-type value is empty or not specified. The default values will be set as follow:"
      [[ ${scripting} == "false" ]] && echo "--domain-type=master"
      domain_type="master"
      json_query_data=$(jq --arg type "${domain_type}" '.type |= $type' <<<"${json_query_data}")
    fi

    # Validate domain_email if domain type = master

    if [ -n "${domain_email}" ]; then
      if is_valid email "${domain_email}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --domain-email ${domain_email} is a valid"
        json_query_data=$(jq --arg soa_email "${domain_email}" '.soa_email |= $soa_email' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --domain-email ${domain_email} is not a valid"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
    else
      if [ "${domain_type}" == "master" ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, the option --domain-email value is empty or not specified for --domain-type master. The default values will be set as follow:"
        [[ ${scripting} == "false" ]] && echo "--domain-email=webmaster@${domain_name}"
        domain_email="webmaster@${domain_name}"
        json_query_data=$(jq --arg soa_email "${domain_email}" '.soa_email |= $soa_email' <<<"${json_query_data}")
      fi
    fi

    #  Validate domain_master_ips
    if [ -n "${domain_master_ips}" ]; then
      for domain_master_ip in ${domain_master_ips[*]}; do
        # TODO validate each domain_master_ip variable here before creating the post data (validate for IPv4 and IPv6)
        # TODO this is working but without validation now
        json_query_data=$(jq --arg domain_master_ip "${domain_master_ip}" '.master_ips |= .  + [$domain_master_ip] ' <<<"${json_query_data}")
      done
    else
      if [ "${domain_type}" == "slave" ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, the option --domain-master-ips value is empty for --domain-type slave. You have to specify at least 1 IP address (eg: --domain-master-ip 1.1.1.1 or --domain-master-ips \"1.2.3 2.3.3.3 ::1\")"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
    fi

    # Validate domain ttl
    if [ -n "${domain_ttl}" ]; then
      if is_valid domain_ttl "${domain_ttl}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --domain-ttl ${domain_ttl} is a valid"
        json_query_data=$(jq --argjson ttl_sec "${domain_ttl}" '.ttl_sec |= $ttl_sec' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --domain-ttl ${domain_ttl} is not a valid"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
    fi

    # validate domain status
    if [ -n "${domain_status}" ]; then
      if is_valid domain_status "${domain_status}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --domain-status ${domain_status} is a valid"
        json_query_data=$(jq --arg status "${domain_status}" '.status |= $status' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --domain-status ${domain_status} is not a valid"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
    fi

    # If the option --rebuild is passed, we must delete this domain first before creating the new one (useful for force creating a domain from scratch)
    if [ "${rebuild_value}" == "true" ]; then
      local domain_id
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, the option --rebuild is enabled. The existing domain ${domain_name} will be deleted first (if found) before creating a new one"

      [[ ${scripting} == "false" ]] && echo "[${caller}]: Checking for an existing --domain-name ${domain_name} ..."

      domain_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/domains?page_size=${linode_max_page_size}" | jq -r ".data[] | select(.domain == \"${domain_name}\") | .id")
      status_handler check --curl-status "$?"

      if [ -n "${domain_id}" ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, found existing domain name ${domain_name}. Deleting the existing domain ${domain_name} ..."
        response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "${api_auth_string}" -X DELETE --url "${api_url}/domains/${domain_id}")
        status_handler check --curl-status "$?" --http-status "${response_code}"
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, no existing domain ${domain_name} is found"
      fi
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: json query is:"
    [[ ${scripting} == "false" ]] && echo "${json_query_data}"

    # Now we create the domain
    [[ ${scripting} == "false" ]] && echo "[${caller}]: Creating a domain name ${domain_name} ..."

    response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "Content-Type: application/json" -H "${api_auth_string}" -X POST --data "${json_query_data}" --url "${api_url}/domains")
    status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success \
      --error-msg "there was something wrong when creating the domain name ${domain_name}" --success-msg "the domain name ${domain_name} has been created"

    # v1.0
  elif [[ "${action^^}" == +(UPDATE-DOMAIN|DOMAIN-UPDATE|EDIT-DOMAIN|DOMAIN-EDIT) ]]; then
    local domain_id json_query_data

    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: ${action}"
      echo "Required option(s):"
      echo "   --for-domain <domain_name>"
      echo "Purpose: This action is used to update a domain in linode based on a given domain name"
      echo "Notes:"
      echo "The option --domain-name, --domain-type, --domain-email, --domain-master-ip, --domain-status are optional options"
      echo "If you don't use them for update, it will only update the domain timestamp database called 'update'"
      echo "If you change the --domain-type from master to slave, the --domain-master-ip option is required for update if the option was not supplied when creating a master domain"
      echo "If you change the --domain-type from slave to master, the --domain-email option is required for update if the option was not supplied when creating a slave domain"
      echo "You will not be able to update some domain name that are reserved in linode domain management (eg: microsoft.com, apple.com)"
      echo "Example 1 (to update or change a domain name from sofibox.com to sofihost.com):"
      echo "    ${SCRIPT_NAME} linode ${action} --for-domain sofibox.com --domain-name sofihost.com"
      echo "Example 2 (to covert domain type from master to slave, and you must give at least 1 domain master IP):"
      echo "    ${SCRIPT_NAME} linode ${action} --for-domain sofibox.com --domain-type slave --domain-master-ip 1.1.1.1"
      echo "Example 3: (to update domain email to myemail@domain.com and domain ttl to 30 seconds)"
      echo "    ${SCRIPT_NAME} linode ${action} --for-domain sofibox.com --domain-email myemail@domain.com --domain-ttl 30"
      echo "Example 4: (to disable an existing domain)"
      echo "    ${SCRIPT_NAME} linode ${action} --for-domain-name sofibox.com --domain-status disabled"
      echo ""
      _exit 0
    fi

    json_query_data='{}'

    if [ -z "${for_domain_name}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --for-domain option is required with a value. Please, provide a valid input (eg: --for-domain domain.com)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    # Validate domain name - this is optional variable
    if [ -n "${domain_name}" ]; then
      if is_valid domain "${domain_name}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --domain-name ${domain_name} is a valid FQDN"
        json_query_data=$(jq --arg domain "${domain_name}" '.domain |= $domain' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --domain-name ${domain_name} is not a valid FQDN"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

    fi

    #2) Validate domain type - this is optional variable
    if [ -n "${domain_type}" ]; then
      if is_valid domain_type "${domain_type}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --domain-type ${domain_type} is a valid: ${domain_type}"
        json_query_data=$(jq --arg type "${domain_type}" '.type |= $type' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --domain-type ${domain_type} is not a valid"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
    fi

    #3 ) Validate domain email - this is optional variable
    if [ -n "${domain_email}" ]; then
      if is_valid email "${domain_email}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --domain-email ${domain_email} is a valid"
        json_query_data=$(jq --arg soa_email "${domain_email}" '.soa_email |= $soa_email' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --domain-email ${domain_email} is not a valid"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
    fi

    #  Validate domain master ip(s) - this is optional variable
    if [ -n "${domain_master_ips}" ]; then
      for domain_master_ip in ${domain_master_ips[*]}; do
        # TODO validate each domain_master_ip variable here before creating the post data (validate for IPv4 and IPv6)
        # TODO this is working but without validation now
        json_query_data=$(jq --arg domain_master_ip "${domain_master_ip}" '.master_ips |= .  + [$domain_master_ip] ' <<<"${json_query_data}")
      done
    else
      if [ "${domain_type}" == "slave" ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Notice, the option --domain-master-ips value is empty for --domain-type slave. You have to specify at least 1 IP address (eg: --domain-master-ip 1.1.1.1 or --domain-master-ips \"1.2.3 2.3.3.3 ::1\")"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
    fi

    #4) Validate domain ttl - this is optional variable
    if [ -n "${domain_ttl}" ]; then
      if is_valid domain_ttl "${domain_ttl}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --domain-ttl ${domain_ttl} is a valid"
        json_query_data=$(jq --argjson ttl_sec "${domain_ttl}" '.ttl_sec |= $ttl_sec' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --domain-ttl ${domain_ttl} is not a valid"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
    fi

    # Validate domain status - this is optional variable
    if [ -n "${domain_status}" ]; then
      if is_valid domain_status "${domain_status}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --domain-status ${domain_status} is a valid"
        json_query_data=$(jq --arg status "${domain_status}" '.status |= $status' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --domain-status ${domain_status} is not a valid"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Getting a required domain ID for --for-domain-name ${for_domain_name} ..."

    domain_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/domains?page_size=${linode_max_page_size}" | jq ".data[] | select(.domain == \"${for_domain_name}\") | .id")
    status_handler check --curl-status "$?"

    if [ -z "${domain_id}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no domain ID is found when searching --for-domain-name ${for_domain_name}"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: json query data is:"
    [[ ${scripting} == "false" ]] && echo "${json_query_data}"

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Updating the domain name ${for_domain_name} ..."

    response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "Content-Type: application/json" \
      -H "${api_auth_string}" -X PUT --data "${json_query_data}" --url "${api_url}/domains/${domain_id}")
    status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success \
      --error-msg "there was something wrong when updating the domain name ${for_domain_name}" \
      --success-msg "the domain name ${for_domain_name} has been updated"

    # v1.0
  elif [[ "${action^^}" == +(DELETE-DOMAINS|REMOVE-DOMAINS|DELETE-DOMAIN|REMOVE-DOMAIN) ]]; then
    local domain_id domain_ids domain_ids_count domain_count

    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: delete-domains / delete-domain"
      echo "Required option(s):"
      echo "   --for-domain <domain_name> (REQUIRED ONLY if the action does not end with postfix -s)"
      echo "Purpose: This action is used to delete domain(s) in linode based on a given domain name"
      echo "Notes:"
      echo "You might want to use the option --first-record to delete only the first record or --last-record to delete only the last record"
      echo "When deleting a domain, we do not need to check for busy status. If linode or disk status is busy, we can still delete it without an issue"
      echo "Linode only allow unique a domain name but in case if domain name can be duplicated, you can delete multiple domains with one command that have the same label name but you will be prompted before deleting multiple domains"
      echo "Use the action ending with postfix -s to search for all existing domains in linode and it does not require --for-domain option to search domain"
      echo "Warning, if you supply the --scripting option, you will not have a prompt for this action. This may delete multiple domains without a prompt (use at your own risk)"
      echo "Example 1: (delete a specific domain)"
      echo "    ${SCRIPT_NAME} linode delete-domain --for-domain sofibox.com"
      echo "Example 2 (delete the last created domain using the option --last-record):"
      echo "    ${SCRIPT_NAME} linode delete-domains --last-record"
      echo "Example 3 (you will not have prompt if you pass the option --last-record or --first-record or --scripting or the domain count is 1):"
      echo "    ${SCRIPT_NAME} linode delete-domains --first-record"
      echo "Example 4 (this will delete domains with a prompt)"
      echo "    ${SCRIPT_NAME} linode delete-domains"
      echo "Example 5 (this will delete all domains without a prompt - to abort the deletion process press CTRL + C)"
      echo "    ${SCRIPT_NAME} linode delete-domains --scripting"
      echo ""
      _exit 0
    fi

    if [[ "${action^^}" == +(DELETE-DOMAINS|REMOVE-DOMAINS) ]]; then

      [[ ${scripting} == "false" ]] && echo "[${caller}]: Searching all domains in linode ... "

      domain_ids=$(curl -s -H "${api_auth_string}" --url "${api_url}/domains?page_size=${linode_max_page_size}" | jq -r ".data[] | .id")
      status_handler check --curl-status "$?"

      if [ -z "${domain_ids}" ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode domain is found"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
    else # delete-domain or remove-domains
      if [ -z "${for_domain_name}" ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the action ${action} (without a postfix -s) required --for-domain option with a value to search an existing domain. Please, provide a valid input (eg: --for-domain domain.com)"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Searching for domain ${for_domain_name} in linode ... "

      # By logic, this will always return 1 if found but we don't know the API might change to have duplicated domain names. So use this.
      domain_ids=$(curl -s -H "${api_auth_string}" --url "${api_url}/domains?page_size=${linode_max_page_size}" | jq -r ".data[] | select(.domain == \"${for_domain_name}\") | .id")
      status_handler check --curl-status "$?"

      if [ -z "${domain_ids}" ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode domain ${for_domain_name} is found"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

    fi

    # If the option --first-record or --last-record is there, we filter this to only use one record
    if [ "${first_record}" == true ]; then
      domain_ids=$(echo "${domain_ids}" | head -n1)
      [[ ${scripting} == "false" ]] && echo "[${caller}]: List of domain ID selected (first record): "
    elif [ "${last_record}" == true ]; then
      domain_ids=$(echo "${domain_ids}" | tail -n1)
      [[ ${scripting} == "false" ]] && echo "[${caller}]: List of domain ID selected (last record): "

    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: List of domain ID(s) selected: "
    fi

    domain_ids_count=$(echo "${domain_ids}" | wc -w)

    [[ ${scripting} == "false" ]] && echo "${domain_ids}" | tr -s '\n' ' '
    [[ ${scripting} == "false" ]] && echo ""

    if [[ "${domain_ids_count}" -gt 1 && "${without_prompt}" == false ]]; then
      [[ ${scripting} == "false" ]] && _confirm "[${caller}->input]: Warning, found ${domain_ids_count} domain records. Do you want to delete them?" n
    fi

    domain_count=0

    for domain_id in ${domain_ids[*]}; do
      local domain_name response_code
      ((domain_count++))

      # This is just for obtaining the domain name based on a given ID (for display purpose)
      domain_name=$(curl -s -H "${api_auth_string}" --url "${api_url}/domains?page_size=${linode_max_page_size}" | jq -r ".data[] | select(.id == ${domain_id}) | .domain")
      status_handler check --curl-status "$?"

      [[ ${scripting} == "false" ]] && echo "[${caller}]: Deleting linode domain ${domain_name} ( ${domain_id} ) ... ${domain_count} / ${domain_ids_count}"

      response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "${api_auth_string}" -X DELETE --url "${api_url}/domains/${domain_id}")
      status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success \
        --error-msg "there was something wrong when deleting the domain name ${domain_name}" \
        --success-msg "the domain name ${domain_name} has been deleted"

    done

  # v1.0
  elif [[ "${action^^}" == +(DOMAIN-CREATE-RECORD|CREATE-RECORD|CREATE-DOMAIN-RECORD|DOMAIN-ADD-RECORD|ADD-DOMAIN-RECORD|CREATE-DNS-RECORD|DNS-CREATE-RECORD|ADD-DNS-RECORD|DNS-ADD-RECORD) ]]; then
    local domain_id json_query_data

    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: ${action}"
      echo "Required option(s):"
      echo "   --for-domain <domain_name>"
      echo "   --record-type <record_type>"
      echo "Purpose: This action is used to create a domain record in linode based on a given domain name and record type"
      echo "Notes:"
      echo "The --record-type <record_type> is required to validate both --record-name and --record-value to be created"
      echo ""
      echo "For TXT record rules:"
      echo "1) Record name is actually a hostname and it is not required. You can use the option --record-hostname as an alias"
      echo "2) If the record name is provided, it must not have invalid character except underscore such as: *['!'@#\$%^\&*()+]*"
      echo "3) Record target/value can be anything and it is also not required"
      echo "4) Both record name and target are not required and can be emptied"
      echo "Example 1: So you can create TXT empty record using the following commands:"
      echo "   ${SCRIPT_NAME} linode ${action} --for-domain sofibox.com --record-type TXT"
      echo "Example 2: You can modify the TTL record using --record-ttl <time_in_second>"
      echo "   ${SCRIPT_NAME} linode ${action} --for-domain sofibox.com --record-type TXT --record-name _dmarc --record-value _dmarc.sofibox.com --ttl-record 30"
      echo ""
      echo "For MX record rules:"
      echo "1) Record name is actually the subdomain for email (eg: mail) and it is required. You can use the option --record-subdomain as an alias"
      echo "2) Record value is actually a domain/hostname/server for email (eg: sofibox.com) and it is required too. You can use --record-domain or --record-hostname  or --record-server as an alias option"
      echo "3) Record priority must be supplied or MX record but if you leave it empty, it will use the default priority which is 0. You can use --record-priority as the alias option"
      echo "Example 1: Create an MX record with some options"
      echo "   ${SCRIPT_NAME} linode ${action} --domain-name test.com --type MX --record-name mail --record-value sofibox.com. --record-priority 10 --record-ttl 30"
      echo ""
      echo "For NS record rules:"
      echo "1) Record name is actually the nameserver and it is required. You can use option --record-nameserver as an alias"
      echo "2) Record value/target is actually the subdomain and it must not contain special character except underscore such as: *['!'@#\$%^\&*()+]*. You can use --record-subdomain or record--hostname as an alias"
      echo "3) If the record value/target given is empty it will use the root domain name as the default value"
      echo "4) If the record value/target given is just a subdomain text, it will append to root domain (eg: subdomain.root-domain.com)"
      echo "5) If record value/target given is a valid domain name or hostname, it will use that value"
      echo "Example 1: This will create a --record-type NS with record name ns1.sofibox.com and --record-value server.sofibox.com"
      echo "   ${SCRIPT_NAME} linode ${action} --for-domain sofibox.com --record-type NS --record-name ns1.sofibox.com --record-value server"
      echo ""
      echo "For A record rules:"
      echo "1) The record name is also known as hostname or domain or subdomain and it is not required. If you leave it empty, it will use the root domain. You can use --record-hostname, or --record-subdomain, or record-domain as an alias option"
      echo "2) For record name, you can pass a value '@' to refer to a root domain and you can also use the value '*' to indicate that the record want to use wildcard domain. You must quote both '@' and '*'"
      echo "3) The record value should be IP address for IPv4 and it is required. You can use --ip-address as an alias option"
      echo "4) Linode use the same entry for A and AAAA (it just detects the IP format and apply the record type automatically based on IP format)"
      echo "Example 1: Create an A record with --record-name 'dashboard' and --record-value or --ip-address 1.2.3.4"
      echo "   ${SCRIPT_NAME} linode ${action}--domain test.com --record-type A --record-name dashboard --ip-address 1.2.3.4 --record-ttl 30"
      echo ""
      echo "For AAAA record rules:"
      echo "1) The record name is also known as hostname or domain or subdomain and it is not required. If you leave it empty, it will use the root domain. You can use --record-hostname, or --record-subdomain, or record-domain as an alias option"
      echo "2) For record name, you can pass a value '@' to refer to a root domain and you can also use the value '*' to indicate that the record want to use wildcard domain. You must quote both '@' and '*'"
      echo "3) The record value should be IP address for IPv6 and it is required. You can use --ip-address as an alias option"
      echo "4) Linode use the same entry for A and AAAA (it just detects the IP format and apply the record type automatically based on IP format)"
      echo "Example 1: Create an AAAA record with --record-name 'dashboard' and --record-value or --ip-address ::1"
      echo "   ${SCRIPT_NAME} linode ${action}--domain test.com --record-type AAAA --record-name dashboard --ip-address ::1 --record-ttl 30"
      echo ""
      echo "For CNAME record rules:"
      echo "1) The record name is known as hostname and it is required. This record cannot contain any special characters except underscore. You can use --record-hostname as an alias option"
      echo "2) The record value is also known as hostname (or alias to) and it is not required. If you leave it empty it will use the root domain. You can use --record-alias as an alias option"
      echo "Example 1: Create a CNAME record with -record--name 'abc.com' and --record-value 'def.com'"
      echo "   ${SCRIPT_NAME} linode ${action} --domain test.com --record-type CNAME --record-name abc.com --record-value def.com --record-ttl 30"
      echo ""
      echo "For the other records, coming soon ..."
      echo ""
      _exit 0
    fi

    json_query_data='{}'

    # This --for-domain is required
    if [ -z "${for_domain_name}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --for-domain option is required with a value. Please, provide a valid input (eg: --for-domain domain.com)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Getting a required domain ID --for=domain ${for_domain_name} ..."

    domain_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/domains?page_size=${linode_max_page_size}" | jq ".data[] | select(.domain == \"${for_domain_name}\") | .id")
    status_handler check --curl-status "$?"

    if [ -z "${domain_id}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no domain is found --for-domain ${for_domain_name}"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    # This --record-type is required
    if is_valid record_type "${record_type}"; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-type ${record_type} is valid"
      json_query_data=$(jq --arg type "${record_type}" '.type |= $type' <<<"${json_query_data}")
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --record-type ${record_type} is not a valid. Please provide a valid input (eg: --record-type TXT)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    # 3) Validate domain record ttl if given (this is optional)
    if [ -n "${record_ttl}" ]; then
      if is_valid record_ttl "${record_ttl}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-ttl ${record_ttl} is valid"
        json_query_data=$(jq --argjson ttl_sec "${record_ttl}" '.ttl_sec |= $ttl_sec' <<<"${json_query_data}")

      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --record-ttl ${record_ttl} is not a valid. Please provide a valid input (eg: --record-ttl 30)"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
    fi

    # Now create the record based on --record-type

    # v1.0
    if [ "${record_type}" == "TXT" ]; then

      # We use the friendly alias options here
      if [ -n "${record_hostname}" ]; then
        record_name="${record_hostname}"
      fi

      # Validate the record name not to have invalid character if given (this record name for TXT type is not required)
      if [ -n "${record_name}" ]; then
        if is_valid server_record_valid_character "${record_name}"; then
          [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-name ${record_name} (for record hostname) is valid"

        else
          [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --record-name ${record_name} (for record hostname) is invalid"
          [[ ${scripting} == "true" ]] && echo "error"
          _exit 1
        fi
        json_query_data=$(jq --arg name "${record_name}" '.name |= $name' <<<"${json_query_data}")

      fi

      # Note For record target/value, we don't have to validate it as it accepted any texts
      json_query_data=$(jq --arg target "${record_value}" '.target |= $target' <<<"${json_query_data}")

      # Create the DNS record for TXT (giving only text)
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Creating a TXT --record-name [ ${record_name} ] and --record-value [ ${record_value} ] --where-domain-is-domain ${for_domain_name} ..."

    # v1.0
    elif [ "${record_type}" == "MX" ]; then
      if [ -n "${record_subdomain}" ]; then
        record_name="${record_subdomain}"
      fi

      if [ -n "${record_domain}" ]; then
        record_value="${record_domain}"
      fi
      if [ -n "${record_hostname}" ]; then
        record_value="${record_hostname}"
      fi
      if [ -n "${record_server}" ]; then
        record_value="${record_server}"
      fi

      # 1) Validate server name record (or record name)

      if is_valid domain "${record_name}" && is_valid server_record_valid_character "${record_name}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-name ${record_name} (for record subdomain) is valid"
        json_query_data=$(jq --arg name "${record_name}" '.name |= $name' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --record-name ${record_name} (for record subdomain) is invalid"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

      # 2) Validate domain/hostname record
      if is_valid domain "${record_value}" && is_valid domain "${record_value}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-value ${record_value} (for record mail server) is valid"
        json_query_data=$(jq --arg target "${record_value}" '.target |= $target' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --record-value ${record_value} (for record mail server) is invalid"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

      if [ -n "${record_priority}" ]; then
        # 3) Validate record priority value
        if is_valid record_priority "${record_priority}"; then
          [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-priority ${record_priority} (for record preference) is valid"
          json_query_data=$(jq --argjson priority "${record_priority}" '.priority |= $priority' <<<"${json_query_data}")
        else
          [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --record-priority ${record_priority} (for record preference) is not valid"
          [[ ${scripting} == "true" ]] && echo "error"
          _exit 1
        fi

      fi

      # Create the DNS record for MX (giving only text)
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Creating an MX --record-name [ ${record_name} ] and --record-value [ ${record_value} ] --where-domain-is-domain ${for_domain_name} ..."
    # v1.0
    elif [ "${record_type}" == "NS" ]; then

      if [ -n "${record_nameserver}" ]; then
        record_name="${record_nameserver}"
      fi
      if [ -n "${record_hostname}" ]; then
        record_value="${record_hostname}"
      fi
      if [ -n "${record_subdomain}" ]; then
        record_value="${record_subdomain}"
      fi

      # Validate record name server (or record name) it is required
      if is_valid domain "${record_name}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-name ${record_name} (for record name server) is valid"
        json_query_data=$(jq --arg name "${record_name}" '.name |= $name' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --record-name ${record_name} (for record name server) is invalid"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

      if [ -z "${record_value}" ]; then
        record_value="${for_domain_name}"
      elif is_valid server_record_valid_character "${record_value}"; then
        record_value="${record_value}.${for_domain_name}"
      fi

      if is_valid domain "${record_value}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-value ${record_value} (for record subdomain) is valid"
        json_query_data=$(jq --arg target "${record_value}" '.target |= $target' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --record-value ${record_value} (for record subdomain) is invalid"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

      # Create the DNS record for NS (giving only text)
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Creating an NS --record-name [ ${record_name} ] and --record-value [ ${record_value} ] --where-domain-is-domain ${for_domain_name} ..."
      # v1.0
    elif [[ "${record_type}" == "A" ]]; then
      if [ -n "${record_hostname}" ]; then
        record_name="${record_hostname}"
      fi

      if [ -n "${record_subdomain}" ]; then
        record_name="${record_subdomain}"
      fi
      if [ -n "${record_domain}" ]; then
        record_name="${record_domain}"
      fi
      if [ -n "${ip_address}" ]; then
        record_value="${ip_address}"
      fi

      if [[ -z "${record_name}" || "${record_name}" == "@" ]]; then
        record_name="${for_domain_name}"
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-name ${record_name} (for record hostname) is valid"
        json_query_data=$(jq --arg name "${record_name}" '.name |= $name' <<<"${json_query_data}")
      elif [ "${record_name}" == "*" ]; then
        record_name="*"
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-name ${record_name} (for record hostname) is valid"
        json_query_data=$(jq --arg name "${record_name}" '.name |= $name' <<<"${json_query_data}")
      # Extra validation to include wildcard character in DNS record * and @ for root domain
      elif is_valid domain "${record_name}" || is_valid server_record_valid_character "${record_name}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-name ${record_name} (for record hostname) is valid"
        json_query_data=$(jq --arg name "${record_name}" '.name |= $name' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --record-name ${record_name} (for record hostname) is invalid"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

      if is_valid ipv4 "${record_value}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-value ${record_value} (for record IPv4 address) is valid"
        json_query_data=$(jq --arg target "${record_value}" '.target |= $target' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Warning, the given --record-value ${record_value} (for record IPv4 address) is not valid"
        _exit 1
      fi

      [[ ${scripting} == "false" ]] && echo "[${caller}]: Creating an A (IPv4) --record-name [ ${record_name} ] and --record-value [ ${record_value} ] --where-domain-is-domain ${for_domain_name} ..."

      # v1.0
    elif [[ "${record_type}" == "AAAA" ]]; then
      if [ -n "${record_hostname}" ]; then
        record_name="${record_hostname}"
      fi

      if [ -n "${record_subdomain}" ]; then
        record_name="${record_subdomain}"
      fi
      if [ -n "${record_domain}" ]; then
        record_name="${record_domain}"
      fi
      if [ -n "${ip_address}" ]; then
        record_value="${ip_address}"
      fi

      if [[ -z "${record_name}" || "${record_name}" == "@" ]]; then
        record_name="${for_domain_name}"
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-name ${record_name} (for record hostname) is valid"
        json_query_data=$(jq --arg name "${record_name}" '.name |= $name' <<<"${json_query_data}")
      elif [ "${record_name}" == "*" ]; then
        record_name="*"
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-name ${record_name} (for record hostname) is valid"
        json_query_data=$(jq --arg name "${record_name}" '.name |= $name' <<<"${json_query_data}")
      # Extra validation to include wildcard character in DNS record * and @ for root domain
      elif is_valid domain "${record_name}" || is_valid server_record_valid_character "${record_name}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-name ${record_name} (for record hostname) is valid"
        json_query_data=$(jq --arg name "${record_name}" '.name |= $name' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --record-name ${record_name} (for record hostname) is invalid"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

      if is_valid ipv6 "${record_value}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-value ${record_value} (for record IPv6 address) is valid"
        json_query_data=$(jq --arg target "${record_value}" '.target |= $target' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Warning, the given --record-value ${record_value} (for record IPv6 address) is not valid"
        _exit 1
      fi

      [[ ${scripting} == "false" ]] && echo "[${caller}]: Creating an AAAA (IPv6) --record-name [ ${record_name} ] and --record-value [ ${record_value} ] --where-domain-is-domain ${for_domain_name} ..."
      # For CNAME record rules:
      # 1) The record name is actually a hostname and it is required. This record cannot contain any special characters except underscore. You can use --record-hostname as an alias option.
      # 2) The record value is also known as hostname (or alias to) and it is not required. If you leave it empty it will use the root domain. You can use --record-alias as an alias option.
      # maxipi linode create-dns-record --domain test.com --record-type AAAA --record-name ip_address --record-value value --record-ttl 30

    elif [ "${record_type}" == "CNAME" ]; then
      if [ -n "${record_hostname}" ]; then
        record_name="${record_hostname}"
      fi

      if [ -n "${record_alias}" ]; then
        record_value="${record_alias}"
      fi

      if [ "${record_name}" == "*" ]; then
        record_name="*"
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-name ${record_name} (for record hostname) is valid"
        json_query_data=$(jq --arg name "${record_name}" '.name |= $name' <<<"${json_query_data}")
      elif is_valid server_record_valid_character "${record_name}" && [ -n "${record_name}" ]; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-name ${record_name} (for record hostname) is valid"
        json_query_data=$(jq --arg name "${record_name}" '.name |= $name' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --record-name ${record_name} (for record hostname) is invalid"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

      if [[ -z "${record_value}" || "${record_value}" == "@" ]]; then
        record_value="${for_domain_name}"
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-value ${record_value} (for record hostname) is valid"
        json_query_data=$(jq --arg target "${record_value}" '.target |= $target' <<<"${json_query_data}")
      # Extra validation to include wildcard character in DNS record * and @ for root domain
      elif is_valid domain "${record_value}" || is_valid server_record_valid_character "${record_value}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-value ${record_value} (for record hostname) is valid"
        json_query_data=$(jq --arg target "${record_value}" '.target |= $target' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --record-value ${record_value} (for record hostname) is invalid"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

      [[ ${scripting} == "false" ]] && echo "[${caller}]: Creating a CNAME --record-name [ ${record_name} ] and --record-value [ ${record_value} ] --where-domain-is-domain ${for_domain_name} ..."

    elif [ "${record_type}" == "SRV" ]; then
      :
    elif [ "${record_type}" == "CAA" ]; then
      :
    elif [ "${record_type}" == "PTR" ]; then
      :
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: json post query is:"
    [[ ${scripting} == "false" ]] && echo "${json_query_data}"

    response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "Content-Type: application/json" -H "${api_auth_string}" -X POST --data "${json_query_data}" --url "${api_url}/domains/${domain_id}/records")
    status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success --error-msg "there was something wrong when creating the domain record for domain ${domain_name}" --success-msg "the domain record for domain ${domain_name} has been created"

    #v1.0
  elif [[ "${action^^}" == +(DOMAIN-UPDATE-RECORD|UPDATE-DOMAIN-RECORD|DOMAIN-EDIT-RECORD|EDIT-DOMAIN-RECORD|UPDATE-DNS-RECORD|DNS-UPDATE-RECORD) ]]; then

    local domain_id record_ids json_search_string json_query_data

    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: ${action}"
      echo "Required option(s):"
      echo "   --for-domain <domain_name>"
      echo "This action also required at least one of the following search options for searching existing domain record to be updated"
      echo "   --for-record-name <record_name>, --for-record-value <record_value>, --for-record-type <record_type>"
      echo "Purpose: This action is used to update domain record(s) in linode based on a given domain name and one or more search options"
      echo "Notes:"
      echo "You might want to use the option --first-record to update only the first record or --last-record to update only the last record"
      echo "When you search for a record that is not editable for example linode name server, it will not show up in the result"
      echo "When using this action, record name and record value don't have alias. For example to update an IPv4 of a domain record, you cannot use an alias --ip-address instead you use --record-value"
      echo "Warning, if you supply the --scripting option, you will not have a prompt for this action. This may update multiple domain records without a prompt (use at your own risk)"
      echo "You can use the following record update options to update record: "
      echo "   --record-name <record_name>, --record-value <record_value>, --record-ttl <record_ttl>, --record-priority <record_priority>"
      echo "If you don't use any record update options above, it will only update the timestamp of the domain record"
      echo "Example 1: (This will search all records with the record-name www and update its IP to 1.1.1.1)"
      echo "    ${SCRIPT_NAME} linode ${action} --for-domain sofibox.com --for-record-name www --record-value 1.1.1.1"
      echo "Example 2 (This will search record with record type of TXT and update the DKIM value to 123 where the key name is _dkim):"
      echo "    ${SCRIPT_NAME} linode ${action} --for-domain sofibox.com --for-record-type TXT --for-record-name _dkim --record-value 123"
      echo "Example 3 (This will update an MX record with hostname abc.com with priority 100 and record ttl to 30):"
      echo "    ${SCRIPT_NAME} linode ${action} --for-domain sofibox.com --for-record-type MX --for-record-name abc.com --record-priority 100 --record-ttl 30"
      echo ""
      _exit 0
    fi

    if [ -z "${for_domain_name}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --for-domain option is required with a value. Please, provide a valid input (eg: --for-domain domain.com)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Getting a required domain ID --for-domain-name ${for_domain_name} ..."

    domain_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/domains?page_size=${linode_max_page_size}" | jq -r ".data[] | select(.domain == \"${for_domain_name}\") | .id")
    status_handler check --curl-status "$?"

    if [ -z "${domain_id}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no domain is found --for-domain ${for_domain_name}"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    # Create a json search string
    if [ -n "${for_record_name}" ]; then
      if [ -z "${json_search_string}" ]; then
        json_search_string="(.name==\"${for_record_name}\")"
      else
        json_search_string="${json_search_string} and (.name==\"${for_record_name}\")"
      fi
    fi

    if [ -n "${for_record_value}" ]; then
      if [ -z "${json_search_string}" ]; then
        json_search_string="(.target==\"${for_record_value}\")"
      else
        json_search_string="${json_search_string} and (.target==\"${for_record_value}\")"
      fi
    fi

    if [ -n "${for_record_type}" ]; then
      if [ -z "${json_search_string}" ]; then
        json_search_string="(.type==\"${for_record_type}\")"
      else
        json_search_string="${json_search_string} and (.type==\"${for_record_type}\")"
      fi
    fi

    if [ -z "${json_search_string}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, you must provide at least one search option (eg: --for-record-name abc)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    # Creating data to be updated
    json_query_data='{}'

    if [ -n "${record_name}" ]; then
      json_query_data=$(jq --arg name "${record_name}" '.name |= $name' <<<"${json_query_data}")
    fi

    if [ -n "${record_value}" ]; then
      json_query_data=$(jq --arg target "${record_value}" '.target |= $target' <<<"${json_query_data}")
    fi

    if [ -n "${record_type}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, you do not need to provide --record-type option when doing record update because record TYPE is not editable in linode once created!"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    if [ -n "${record_priority}" ]; then
      if is_valid record_priority "${record_priority}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-priority ${record_priority} (for record preference) is valid"
        json_query_data=$(jq --argjson priority "${record_priority}" '.priority |= $priority' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --record-priority ${record_priority} (for record preference) is not valid"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
    fi

    if [ -n "${record_ttl}" ]; then
      if is_valid record_ttl "${record_ttl}"; then
        [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-ttl ${record_ttl} is valid"
        json_query_data=$(jq --argjson ttl_sec "${record_ttl}" '.ttl_sec |= $ttl_sec' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --record-ttl ${record_ttl} is not a valid"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi
    fi

    # Now we begin search what we want based on json_search_string
    [[ ${scripting} == "false" ]] && echo "[${caller}]: Searching record in domain ${for_domain_name} ..."

    record_ids=$(curl -s -G -H "${api_auth_string}" --url "${api_url}/domains/${domain_id}/records?page_size=${linode_max_page_size}" | jq ".data[] | select(${json_search_string}) | .id")
    status_handler check --curl-status "$?"

    if [[ -n "${record_ids}" ]]; then
      local record_ids_count count_updated count_search

      [[ ${scripting} == "false" ]] && echo ""
      [[ ${scripting} == "false" ]] && echo "Record update details:"
      [[ ${scripting} == "false" ]] && echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="

      # If the option --first-record or --last-record is there, we filter this to only use one record
      if [ "${first_record}" == true ]; then
        record_ids=$(echo "${record_ids}" | head -n1)
        [[ ${scripting} == "false" ]] && echo "[${caller}]: List of Record selected (first record): "
      elif [ "${last_record}" == true ]; then
        record_ids=$(echo "${record_ids}" | tail -n1)
        [[ ${scripting} == "false" ]] && echo "[${caller}]: List of Record selected (last record): "
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: List of Record(s) selected: "
      fi

      count_search=0

      for record_id in ${record_ids}; do
        ((count_search++))
        echo "${count_search}) $(curl -s -G -H "${api_auth_string}" --url "${api_url}/domains/${domain_id}/records?page_size=${linode_max_page_size}" | jq ".data[] | select(.id == ${record_id})")"
      done

      [[ ${scripting} == "false" ]] && echo ""
      [[ ${scripting} == "false" && -n "${for_domain_name}" ]] && echo "Search result for domain name: ${for_domain_name}"
      [[ ${scripting} == "false" && -n "${for_record_name}" ]] && echo "Search result for domain record name: ${for_record_name}"
      [[ ${scripting} == "false" && -n "${for_record_value}" ]] && echo "Search result for domain record value: ${for_record_value}"
      [[ ${scripting} == "false" && -n "${for_record_type}" ]] && echo "Search result for domain record type: ${for_record_type}"
      [[ ${scripting} == "false" && -n "${record_name}" ]] && echo "Record name to be updated: ${record_name}"
      [[ ${scripting} == "false" && -n "${record_value}" ]] && echo "Record value to be updated: ${record_value}"
      [[ ${scripting} == "false" && -n "${record_ttl}" ]] && echo "Record ttl to be updated: ${record_ttl}"
      [[ ${scripting} == "false" && -n "${record_priority}" ]] && echo "Record priority to be updated: ${record_priority}"
      [[ ${scripting} == "false" ]] && echo "Record update timestamp will be updated"
      # [[ ${scripting} == "false" ]] && echo "${record_ids}" | tr -s '\n' ' '

      [[ ${scripting} == "false" ]] && echo ""
      [[ ${scripting} == "false" ]] && echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
      [[ ${scripting} == "false" ]] && echo ""
      record_ids_count=$(echo "${record_ids}" | wc -l)
      # If record more than 1, we give warning and confirmation
      count_updated=1
      if [[ "${record_ids_count}" -gt 1 && "${without_prompt}" == false ]]; then
        [[ ${scripting} == "false" ]] && _confirm "[${caller}->input]: Warning found ${record_ids_count} domain records. Do you want to update them based on the above information?" n
      fi
      # For the output, example if 3 records success, it will print 3 times success
      for record_id in ${record_ids}; do
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Updating the domain record ( ${record_id} ) for the domain ${for_domain_name} ${count_updated}/${record_ids_count}..."

        response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "Content-Type: application/json" -H "${api_auth_string}" \
          -X PUT --data "${json_query_data}" --url "${api_url}/domains/${domain_id}/records/${record_id}")
        status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success \
          --error-msg "there was something wrong when updating the domain record (${record_id}) for domain ${for_domain_name}" \
          --success-msg "the domain record (${record_id}) for domain ${for_domain_name} has been updated"
        ((count_updated++))
      done

    else

      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no domain record is found based on the provided search!"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi
  elif [[ "${action^^}" == +(DOMAIN-DELETE-RECORD|DELETE-DOMAIN-RECORD|DOMAIN-REMOVE-RECORD|REMOVE-DOMAIN-RECORD|DELETE-DNS-RECORD|REMOVE-DNS-RECORD) ]]; then
    local domain_id record_ids json_search_string json_query_data

    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: ${action}"
      echo "Required option(s):"
      echo "   --for-domain <domain_name>"
      echo "This action also required at least one of the following search options for searching existing domain record to be deleted"
      echo "   --for-record-name <record_name>, --for-record-value <record_value>, --for-record-type <record_type>"
      echo "Purpose: This action is used to delete domain record(s) in linode based on a given domain name and one or more search options"
      echo "Notes:"
      echo "DNS records are huge and may contain duplicated entries. So, it is not easy to retrieve them based on reference key like --record-name. So, you can provide more search option to find the exact record"
      echo "You might want to use the option --first-record to delete only the first record or --last-record to delete only the last record"
      echo "When you search for a record that is not editable for example linode name server, it will not show up in the result. Hence, the record cannot be deleted"
      echo "Warning, if you supply the --scripting option, you will not have a prompt for this action. This may delete multiple domain records without a prompt (use at your own risk)"
      echo "Example 1: (This will delete the record name www that has a value 1.1.1.1 (usually from an A record)"
      echo "    ${SCRIPT_NAME} linode ${action} --for-domain sofibox.com --for-record-name www --record-value 1.1.1.1"
      echo "Example 2 (This will search and delete the record with record type of TXT where it contains a record name _dkim):"
      echo "    ${SCRIPT_NAME} linode ${action} --for-domain sofibox.com --for-record-type TXT --for-record-name _dkim --record-value 123"
      echo "Example 3 (Because some records can be duplicated, you can provide more search options to find exactly what you want):"
      echo "    ${SCRIPT_NAME} linode ${action} --for-domain sofibox.com --for-record-type MX --for-record-name abc.com --for-record-value the_value"
      echo ""
      _exit 0
    fi

    if [ -z "${for_domain_name}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --for-domain option is required with a value. Please, provide a valid input (eg: --for-domain domain.com)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Getting a required domain ID for --for-domain-name ${for_domain_name} ..."

    domain_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/domains?page_size=${linode_max_page_size}" | jq -r ".data[] | select(.domain == \"${for_domain_name}\") | .id")
    status_handler check --curl-status "$?"

    if [ -z "${domain_id}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no domain is found --for-domain ${for_domain_name}"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    # Create a json search string
    if [ -n "${for_record_name}" ]; then
      if [ -z "${json_search_string}" ]; then
        json_search_string="(.name==\"${for_record_name}\")"
      else
        json_search_string="${json_search_string} and (.name==\"${for_record_name}\")"
      fi
    fi

    if [ -n "${for_record_value}" ]; then
      if [ -z "${json_search_string}" ]; then
        json_search_string="(.target==\"${for_record_value}\")"
      else
        json_search_string="${json_search_string} and (.target==\"${for_record_value}\")"
      fi
    fi

    if [ -n "${for_record_type}" ]; then
      if [ -z "${json_search_string}" ]; then
        json_search_string="(.type==\"${for_record_type}\")"
      else
        json_search_string="${json_search_string} and (.type==\"${for_record_type}\")"
      fi
    fi

    if [ -z "${json_search_string}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, you must provide at least one search option (eg: --for-record-name abc)"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Searching record in domain ${for_domain_name} ..."

    record_ids=$(curl -s -G -H "${api_auth_string}" --url "${api_url}/domains/${domain_id}/records?page_size=${linode_max_page_size}" | jq ".data[] | select(${json_search_string}) | .id")
    status_handler check --curl-status "$?"

    if [[ -n "${record_ids}" ]]; then
      local record_ids_count count_deleted count_search

      [[ ${scripting} == "false" ]] && echo ""
      [[ ${scripting} == "false" ]] && echo "Record deletion details:"
      [[ ${scripting} == "false" ]] && echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="

      # If the option --first-record or --last-record is there, we filter this to only use one record
      if [ "${first_record}" == true ]; then
        record_ids=$(echo "${record_ids}" | head -n1)
        [[ ${scripting} == "false" ]] && echo "[${caller}]: List of Record selected (first record): "
      elif [ "${last_record}" == true ]; then
        record_ids=$(echo "${record_ids}" | tail -n1)
        [[ ${scripting} == "false" ]] && echo "[${caller}]: List of Record selected (last record): "
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: List of Record(s) selected: "
      fi

      count_search=0

      for record_id in ${record_ids}; do
        ((count_search++))
        echo "${count_search}) $(curl -s -G -H "${api_auth_string}" --url "${api_url}/domains/${domain_id}/records?page_size=${linode_max_page_size}" | jq ".data[] | select(.id == ${record_id})")"
      done

      [[ ${scripting} == "false" ]] && echo ""
      [[ ${scripting} == "false" && -n "${for_domain_name}" ]] && echo "Search result for domain name: ${for_domain_name}"
      [[ ${scripting} == "false" && -n "${for_record_name}" ]] && echo "Search result for domain record name: ${for_record_name}"
      [[ ${scripting} == "false" && -n "${for_record_value}" ]] && echo "Search result for domain record value: ${for_record_value}"
      [[ ${scripting} == "false" && -n "${for_record_type}" ]] && echo "Search result for domain record type: ${for_record_type}"
      [[ ${scripting} == "false" ]] && echo ""
      [[ ${scripting} == "false" ]] && echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
      [[ ${scripting} == "false" ]] && echo ""

      record_ids_count=$(echo "${record_ids}" | wc -l)

      count_deleted=1
      if [[ "${record_ids_count}" -gt 1 && "${without_prompt}" == false ]]; then
        [[ ${scripting} == "false" ]] && _confirm "[${caller}->input]: Warning found ${record_ids_count} domain records. Do you want to delete them based on the above information?" n
      fi

      for record_id in ${record_ids}; do
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Deleting the domain record ( ${record_id} ) for the domain ${for_domain_name} ${count_deleted}/${record_ids_count}..."

        response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "Content-Type: application/json" -H "${api_auth_string}" -X DELETE --url "${api_url}/domains/${domain_id}/records/${record_id}")
        status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success --error-msg "there was something wrong when deleting the domain record (${record_id}) for domain ${for_domain_name}" --success-msg "the domain record (${record_id}) for domain ${for_domain_name} has been deleted"
        ((count_deleted++))
      done
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no domain record is found based on the provided search!"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

  elif [[ "${action^^}" == +(GET-LINODE-IPV4|GET-SERVER-IPV4|GET-IPV4) ]]; then
    local linode_ipv4s
    if [ "${help}" == true ]; then
      echo ""
      echo "Coming soon"
      _exit 0
    fi

    # Make condition if IPv4 more than 1
    linode_ipv4s=$(curl -s -H "Content-Type: application/json" -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | .ipv4[]")
    status_handler check --curl-status "$?"
    if [ "${first_record}" == true ]; then
      linode_ipv4s=$(echo "${linode_ipv4s}" | head -n1)
    elif [ "${last_record}" == true ]; then
      linode_ipv4s=$(echo "${linode_ipv4s}" | tail -n1)
    fi
    if [ -n "${linode_ipv4s}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Success, found one or more IPv4 address(es):"
      [[ ${scripting} == "false" ]] && echo "${linode_ipv4s}"
      [[ ${scripting} == "true" ]] && echo "${linode_ipv4s}"
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no IP address IPv4 is found!"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

  elif [[ "${action^^}" == +(GET-LINODE-IPV6|GET-SERVER-IPV6|GET-IPV6) ]]; then
    # Linode IPv6 can be only 1
    local linode_ipv6
    if [ "${help}" == true ]; then
      echo ""
      echo "Coming soon"
      _exit 0
    fi
    linode_ipv6=$(curl -s -H "Content-Type: application/json" -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | .ipv6")
    status_handler check --curl-status "$?"

    # In case the API allow more than one IPv6 records
    if [ "${first_record}" == true ]; then
      linode_ipv6=$(echo "${linode_ipv6}" | head -n1)
    elif [ "${last_record}" == true ]; then
      linode_ipv6=$(echo "${linode_ipv6}" | tail -n1)
    fi
    if [ -n "${linode_ipv6}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Success, found one or more IPv6 address(es): ${linode_ipv6}"
      [[ ${scripting} == "true" ]] && echo "${linode_ipv6}"
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no IP address IPv6 is found!"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

  elif [[ "${action^^}" == +(UPDATE-LINODE|LINODE-UPDATE|UPDATE-INSTANCE) ]]; then
    local linode_id json_query_data
    if [ "${help}" == true ]; then
      echo ""
      echo "Coming soon"
      _exit 0
    fi
    if [ -z "${for_linode_label}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --for-linode-label option is required with a value. Please, provide a valid input (eg: --for-linode-label server.domain.com)"
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Getting required linode ID for --for-linode-label ${for_linode_label} ..."

    linode_id=$(curl -s -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | select(.label == \"${for_linode_label}\") | .id")
    status_handler check --curl-status "$?"

    if [ -z "${linode_id}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode ID is found when searching for linode label ${for_linode_label}"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    json_query_data='{}'
    if [ -n "${linode_label}" ]; then
      if is_valid not-empty-string "${linode_label}"; then
        json_query_data=$(jq --arg linode_label "${linode_label}" '.label |= $linode_label' <<<"${json_query_data}")
      else
        [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, --linode-label option required a valid value (eg: --linode-label sun.sofibox.com)"
        [[ ${scripting} == "true" ]] && echo "error"
        _exit 1
      fi

    fi

    # This boolean is always passed, we just make sure it is passed
    if [ -n "${linode_enable_watchdog}" ]; then
      json_query_data=$(jq --argjson linode_enable_watchdog "${linode_enable_watchdog}" '.watchdog_enabled |= $linode_enable_watchdog' <<<"${json_query_data}")
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Update query is:"
    [[ ${scripting} == "false" ]] && echo "${json_query_data}"
    [[ ${scripting} == "false" ]] && echo "[${caller}]: Updating the linode ${linode_label} ..."

    response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "Content-Type: application/json" \
      -H "${api_auth_string}" \
      -X PUT --data "${json_query_data}" \
      --url "${api_url}/linode/instances/${linode_id}")
    status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success --error-msg "there was something wrong when updating the linode ${linode_label}" --success-msg "the linode ${linode_label} has been updated"

    # In this case, if we want to find linode label, we can either use IPv4 or IPv6
    # For IPv4, it may return more than 1 labels but I just use tail -n as 1 linode only have 1 label but a linode can have more than 1 IPv4 IP addresses
    # For IPv6, it will return 1. So, we can safely use either IPv4 or IPv6 to check current linode label
    # maxipi linode get-label --ip-address
  elif [[ "${action^^}" == +(GET-LINODE-LABEL|GET-LABEL) ]]; then

    # Linode IPv4 can be one or more use --first-record option to show the first one or --last-record to show the last one
    local linode_label
    if [ "${help}" == true ]; then
      echo ""
      echo "Coming soon"
      _exit 0
    fi
    if [ -n "${ip_address}" ]; then
      linode_ip_address="${ip_address}"
    fi
    if is_valid ipv4 "${linode_ip_address}"; then
      linode_label=$(curl -s -H "Content-Type: application/json" -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | select(.ipv4 | .[] == \"${linode_ip_address}\") | .label" | tail -n 1)
      status_handler check --curl-status "$?"
    elif is_valid ipv6 "${linode_ip_address}"; then
      linode_label=$(curl -s -H "Content-Type: application/json" -H "${api_auth_string}" --url "${api_url}/linode/instances" | jq -r ".data[] | select(.ipv6 | startswith(\"${linode_ip_address}/\")) | .label" | tail -n 1)
      status_handler check --curl-status "$?"
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the IP address ${linode_ip_address} is not valid"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    if [ -n "${linode_label}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Success, linode label for IP address ${ip_address} is ${linode_label}"
      [[ ${scripting} == "true" ]] && echo "${linode_label}"
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no linode label is found for IP address ${ip_address}"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

  elif [[ "${action^^}" == +(IP-ADDRESS-VIEW|GET-IP-ADDRESS-DETAILS) ]]; then
    local response_value
    if [ "${help}" == true ]; then
      echo ""
      echo "Coming soon"
      _exit 0
    fi
    if is_valid ipv4 "${ip_address}" || is_valid ipv6 "${ip_address}"; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --record-value ${ip_address} is valid"
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Warning, the given --record-value ${ip_address} is not valid"
      _exit 1
    fi

    if [ -n "${get_value}" ]; then
      response_value=$(curl -s -H "${api_auth_string}" --url "${api_url}/networking/ips/${ip_address}" | jq -r ".${get_value}")
      status_handler check --curl-status "$?"
    else
      response_value=$(curl -s -H "${api_auth_string}" --url "${api_url}/networking/ips/${ip_address}" | jq -r ".")
      status_handler check --curl-status "$?"
    fi

    if [ -n "${response_value}" ]; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Success, the value for ${get_value} for IP address ${ip_address} is ${response_value}"
      [[ ${scripting} == "true" ]] && echo "${response_value}"
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, no value ${get_value} is found for IP address ${ip_address}"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi
  # v1.0
  elif [[ "${action^^}" == +(UPDATE-REVERSE-DNS|UPDATE-RDNS|UPDATE-LINODE-RDNS) ]]; then

    local response_code json_query_data
    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: ${action}"
      echo "Required option(s):"
      echo "   --for-ip-address <IPv4 or IPv6 address>"
      echo "   --hostname <hostname> or --domain <domain>"
      echo "Purpose: This action is used to update linode reverse DNS for both IPv4 and IPv6"
      echo "Notes:"
      echo "-"
      echo "Example 1: (This will update reverse DNS for the IP address 1.1.1.1 into sun.sofibox.com)"
      echo "    ${SCRIPT_NAME} linode ${action} --for-ip 1.1.1.1 --hostname sun.sofibox.com"
      echo "Example 2: (This will update reverse DNS for the IP address ::1 into mars.sofibox.com)"
      echo "    ${SCRIPT_NAME} linode ${action} --where-ip-is 1.1.1.1 --domain mars.sofibox.com"
      echo ""
      _exit 0
    fi

    # Create alias
    if [ -n "${hostname}" ]; then
      domain_name="${hostname}"
    fi

    if is_valid ipv4 "${for_ip_address}" || is_valid ipv6 "${for_ip_address}"; then
      [[ ${scripting} == "false" ]] && echo "[${caller}]: OK, the given --for-ip-address ${for_ip_address} is valid"
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Warning, the given --for-ip-address ${for_ip_address} is not valid"
      _exit 1
    fi

    json_query_data='{}'

    if is_valid domain "${domain_name}"; then
      json_query_data=$(jq --arg domain_name "${domain_name}" '.rdns |= $domain_name' <<<"${json_query_data}")
    else
      [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given --domain-name ${domain_name} is not FQDN"
      [[ ${scripting} == "true" ]] && echo "error"
      _exit 1
    fi

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Updating reverse DNS for linode --for-ip-address ${for_ip_address} into ${domain_name}"

    response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" -H "Content-Type: application/json" -H "${api_auth_string}" -X PUT --data "${json_query_data}" --url "${api_url}/networking/ips/${for_ip_address}")
    status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success --error-msg "there was something wrong when updating the linode reverse dns --for-ip-address ${for_ip_address}" --success-msg "the linode reverse dns --for-ip-address ${for_ip_address} has been updated into ${domain_name}"

  else

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given action '${action}' does not exist. See ${SCRIPT_NAME} linode --help for more information"
    [[ ${scripting} == "true" ]] && echo "invalid-action"
    _exit 1
  fi

  # [[ ${scripting} == "false" ]] && echo "Arguments: $*"

  _exit 0
}

directadmin_api() {
  local action argnum caller retval short_opts long_opts options api_url api_auth_string

  action="$1"
  argnum="$#"

  # label for script caller
  caller="${SCRIPT_NAME}->${FUNCNAME[0]}"

  API_PROVIDER="directadmin"

  required_packages "jq"

  short_opts="h,c:,v,d,s,q"
  long_opts="help,config-file:,config:,verbose,debug,scripting,without-prompt,quite,sign-as:,signas:,login-as:,for-user:,username:,password:,for-username:,api-username:,\
  api-password:,package-name:,for-package-name:,ip-address:,netmask:,prefix:,add-ip-to-device:"

  options=$(getopt -o "${short_opts}" --long "${long_opts}" -n "[${caller}]" -- "$@")
  retval=$?

  if [ ${retval} != 0 ]; then
    echo "[${caller}]: Error, invalid option"
    _exit 1
  fi

  eval set -- "${options}"

  local help config_file verbose debug scripting without_prompt quite sign_as username password for_username api_username api_password package_name for_package_name ip_address netmask \
    prefix add_ip_to_device

  help=false               # true or false
  config_file=""           # path to config file
  verbose=false            # true or false
  debug=false              # true or false
  scripting="${SCRIPTING}" # true or false based on the global variable SCRIPTING
  without_prompt=false
  quite=false # true or false
  sign_as=""
  username=""
  password=""
  api_username=""
  api_password=""
  for_username=""
  package_name=""
  for_package_name=""
  ip_address=""
  netmask=""
  prefix=""
  add_ip_to_device=""
  while true; do
    local option=$1
    case "${option}" in
    -h | --help)
      help=true
      shift
      ;;
    -c | --config | --config-file)
      config_file="$2"
      shift 2
      ;;
    -v | --verbose)
      verbose=true
      shift
      ;;
    -d | --debug)
      debug=true
      shift
      ;;
    -s | --scripting)
      SCRIPTING=true
      scripting=${SCRIPTING}
      shift
      ;;
    --without-prompt)
      without_prompt=true
      shift
      ;;
    -q | --quite)
      quite=true
      shift
      ;;
    --sign-as | --signas | --login-as | --use-user)
      sign_as="$2"
      shift 2
      ;;
    --username)
      username="$2"
      shift 2
      ;;
    --password)
      password="$2"
      shift 2
      ;;
    --api-username)
      api_username="$2"
      shift 2
      ;;
    --api-password)
      api_password="$2"
      shift 2
      ;;
    --for-username | --for-user)
      for_username="$2"
      shift 2
      ;;
    --package-name)
      package_name="$2"
      shift 2
      ;;
    --for-package-name)
      for_package_name="$2"
      shift 2
      ;;
    --ip-address)
      ip_address="$2"
      shift 2
      ;;
    --netmask)
      netmask="$2"
      shift 2
      ;;
    --prefix)
      prefix="$2"
      shift 2
      ;;
    --add-ip-to-device)
      add_ip_to_device="$2"
      shift 2
      ;;
    --)
      shift
      break
      ;;
    -*)
      opt="$1"
      echo "[${caller}]: Error, invalid option ${opt}. Use --help to see the valid options"
      _exit 1
      ;;
    *)
      break
      ;;
    esac
  done

  if is_valid ssl_site "${DIRECTADMIN_API_PROTOCOL}://${DIRECTADMIN_API_DOMAIN}:${DIRECTADMIN_API_PORT}"; then
    api_url="https://${DIRECTADMIN_API_DOMAIN}:${DIRECTADMIN_API_PORT}"
  else
    api_url="http://${DIRECTADMIN_API_DOMAIN}:${DIRECTADMIN_API_PORT}"
  fi

  if [ -z "${api_username}" ]; then
    api_username="${DIRECTADMIN_API_USERNAME}"
  fi

  if [ -z "${api_password}" ]; then
    api_password="${DIRECTADMIN_API_PASSWORD}"
  fi

  if [ -z "${sign_as}" ]; then
    api_auth_string="${api_username}:${api_password}"
  else
    api_auth_string="${api_username}|${sign_as}:${api_password}"
  fi

  test_account() {
    local cmd_api method data response_code
    local username
    cmd_api="CMD_API_USER_EXISTS"
    method="POST"

    username=${DIRECTADMIN_API_USERNAME}

    if [ -n "${for_username}" ]; then
      username=${for_username}
    fi

    data="user=${username}&json=yes"

    response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" --user "${api_auth_string}" --request "${method}" --data "${data}" --url "${api_url}/${cmd_api}")
    status_handler check --curl-status "$?" --http-status "${response_code}"

    check_account=$(jq -r '. | .exists' "${RESPONSE_FILE}")
    if [ "${check_account}" == "1" ]; then
      echo "Account exist"
    elif [ "${check_account}" == "0" ]; then
      echo "Account does not exist"
    else
      echo "Unknown status code"
    fi
  }

  if [[ "${action^^}" == +(TEST-ACCOUNT|TEST-LOGIN|TEST) ]]; then
    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: ${action}"
      echo "Purpose: This action is used to test the current account whether"
      echo "Notes:"
      echo "If you want the script to return success, just pass the option --scripting"
      echo "Example 1:"
      echo "  ${SCRIPT_NAME} ${API_PROVIDER} ${action}"
      echo "Example 2:"
      echo "  ${SCRIPT_NAME} ${API_PROVIDER} ${action} --scripting"
      echo ""
      _exit 0
    fi
    test_account

  elif [[ "${action^^}" == +(GET-USER-PACKAGE) ]]; then
    local cmd_api method data response_code given_form
    # Only reseller can view this
    cmd_api="CMD_API_PACKAGES_USER"
    method="POST"
    data="package=${for_package_name}&json=yes"
    response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" --user "${api_auth_string}" --request "${method}" --data "${data}" --url "${api_url}/${cmd_api}")
    status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success --error-msg "there was something wrong when trying to get user package ${for_package_name}" --success-msg "the API for ${cmd_api} has been executed successfully"

  elif [[ "${action^^}" == +(ADD-IP|INSERT-IP) ]]; then
    local cmd_api method data response_code
    if [ "${help}" == true ]; then
      echo ""
      echo "Action name: ${action}"
      echo "Required options:"
      echo "  --ip-address <ip_address>"
      echo "  --netmask <IPv6 or IPv4 format (eg: c000:: or 255.255.255.0> or --prefix <IPv6 or IPv4 prefix format> (eg: /32 or /128)"
      echo "Purpose: This action is used to add an IP in DirectAdmin"
      echo "Notes:"
      echo "If you want the script to return success, just pass the option --scripting"
      echo "Example 1:"
      echo "  ${SCRIPT_NAME} ${API_PROVIDER} ${action}"
      echo "Example 2:"
      echo "  ${SCRIPT_NAME} ${API_PROVIDER} ${action} --scripting"
      echo ""
      _exit 0
    fi

    cmd_api="CMD_API_IP_MANAGER"
    method="POST"

    # Check for IPv4 or IPv6 address format
    if ! is_valid ipv46 "${ip_address}"; then
      echo "[${caller}]: Error, invalid IP address ${ip_address}"
      _exit 1
    fi

    if [[ -z "${netmask}" && -z "${prefix}" ]]; then
      echo "[${caller}]: Error, a valid IP address netmask or prefix is required (eg: --netmask 255.255.255.0 or --prefix /24)"
      _exit 1
    fi

    # Check for IPv4 prefix and netmask whether it is valid
    if is_valid ipv4 "${ip_address}"; then
      # Directadmin has bug for accepting more than /32 prefix length but my script prevent that here:

      if [ -n "${netmask}" ]; then
        if ! is_valid ipv4_netmask "${netmask}"; then
          echo "[${caller}]: Error, invalid IPv4 netmask ${netmask}. Please use the valid netmask format (eg: 255.0.0.0 - 255.255.255.0)"
          _exit 1
        else
          given_form="${netmask}"
        fi
      fi

      if [ -n "${prefix}" ]; then
        if ! is_valid ipv4_prefix "${prefix}"; then
          echo "[${caller}]: Error, invalid IPv4 prefix ${prefix}. PLease use the valid prefix format (eg: /1 - /32)"
          _exit 1
        else
          given_form="${prefix}"
        fi

      fi

    # Check for IPv6 prefix is valid based on given netmask
    elif is_valid ipv6 "${ip_address}"; then
      # Directadmin also accept subnet form of IPv6 address but I haven't tested it yet see # TODO ipv6_netmask like ipv4_netmask

      if [ -n "${netmask}" ]; then
        # As for now, --netmask option can be used for providing both prefix and netmask (eg: --netmask c000:: or --netmask /64)
        given_form="${netmask}"
      fi

      if [ -n "${prefix}" ]; then
        if ! is_valid ipv6_prefix "${prefix}"; then
          echo "[${caller}]: Error, invalid prefix ${prefix} for IPv6 address ${ip_address}. Please use the valid prefix range (eg: /1 - /128)"
          _exit 1
        else
          given_form="${prefix}"
        fi

      fi
    fi

    # The add_to_device_aware must be present in API when using the option device=yes
    data="action=add&ip=${ip_address}&netmask=${given_form}&device=yes&add_to_device_aware=yes&json=yes"

    response_code=$(curl -w "%{http_code}" -s -o "${RESPONSE_FILE}" --user "${api_auth_string}" --request "${method}" --data "${data}" --url "${api_url}/${cmd_api}")
    status_handler check --curl-status "$?" --http-status "${response_code}" --print-http-success --error-msg "there was something wrong when trying to add IP address" --success-msg "the API for ${cmd_api} has been executed successfully"

  else

    [[ ${scripting} == "false" ]] && echo "[${caller}]: Error, the given action '${action}' does not exist. See ${SCRIPT_NAME} linode --help for more information"
    [[ ${scripting} == "true" ]] && echo "invalid-action"
    _exit 1
  fi

  # [[ ${scripting} == "false" ]] && echo "Arguments: $*"

  _exit 0

}

digitalocean_api() {
  local action
  action="$1"
  #digitalocean_api_key=$(sed -n 's/^DIGITALOCEAN_API_KEY=//p' "${CONFIG_FILE}" | sed -e 's/^"//' -e 's/"$//')

  if [[ "${action}" == "add-dns-record" ]]; then
    shift
    echo "digitalocean"
    return 0
  fi
}

cloudflare_api() {
  :
}

namecheap_api() {
  :
}

ADMIN_EMAIL="webmaster@sofibox.com"
SCRIPT_PATH="$(dirname "$(readlink -f "$0")")"
SCRIPT_NAME=$(basename -- "$0")
SCRIPT_INSTALL_PATH="/usr/local/maxicode/${SCRIPT_NAME}"
BOX_HOSTNAME=$(hostname)

required_packages "mail" "curl" "ipcalc"

MAIL_BIN=$(command -v mail)

LOG_PATH="${SCRIPT_PATH}/log"
CONFIG_PATH="${SCRIPT_PATH}/conf"
CODE_PATH="${SCRIPT_PATH}/code"
TEMP_PATH="${SCRIPT_PATH}/temp"

mkdir -p "${LOG_PATH}"
mkdir -p "${CONFIG_PATH}"
mkdir -p "${CODE_PATH}"
mkdir -p "${TEMP_PATH}"

# REPORT FILES
DATE_TIME_NOW="$(date '+%d-%m-%Y_%H-%M-%S')"
REPORT_FILE="${LOG_PATH}/${SCRIPT_NAME}-${DATE_TIME_NOW}-report.log"
# This will restore the http response file for the API
RESPONSE_FILE="$(mktemp)"
# This will hold the ID for API provider (eg: linode)
API_PROVIDER=""
# STATUS VARIABLE
RUN_MODE="N/A"
WARN_STATUS="OK"
SCRIPTING=false

RETVAL=0
ACTION="$1"
ARGNUM="$#"

OLD_PATH=""

CONFIG_FILE="${SCRIPT_PATH}/${SCRIPT_NAME}.conf"

if ! [ -s "${CONFIG_FILE}" ]; then
  # Copy a new config file from the template
  cp "${CONFIG_FILE}.sample" "${CONFIG_FILE}"
fi

source "${CONFIG_FILE}"

# Show error if not argument is passed or empty
if [ ${ARGNUM} -eq 0 ]; then
  echo "[${SCRIPT_NAME}]: Error, no argument is supplied. Use [ ${SCRIPT_NAME} --help ] to see the valid options"
  exit 2
fi

while [ "${ARGNUM}" -gt 0 ]; do
  case "${ACTION}" in
  # These commands display usage help text file
  -h | --help | help | /? | ?)
    usage
    RETVAL=$?
    exit ${RETVAL}
    ;;
  -t | --test)

    exit 0
    ;;
  -u | --update | update)
    check_update
    RETVAL=$?
    exit ${RETVAL}
    ;;
  # These commands display Program version
  -v | -V | --version | version | ver)
    echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
    echo ""
    echo "Info: ${_APP_INFO}"
    echo ""
    echo "Version: ${_APP_VERSION_STATUS}"
    echo ""
    echo "${_AUTHOR}"
    echo ""
    echo "=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~="
    RETVAL=$?
    exit ${RETVAL}
    break
    ;;
  show-script-path | get-script-path | script-path)
    echo "${SCRIPT_PATH}"
    RETVAL="$?"
    exit ${RETVAL}
    break
    ;;
  edit-self | edit-script | edit-code | update-code | show-script | editself | editscript | editcode | updatecode | showscript | edit)
    nano -c "${SCRIPT_PATH}/${SCRIPT_NAME}"
    RETVAL=$?
    exit ${RETVAL}
    break
    ;;
  # These commands will handle linode DNS
  lin | lin-cli | lin-api | linode | linode-cli | linode-api)
    shift
    linode_api "$@"
    RETVAL=$?
    exit ${RETVAL}
    break
    ;;
  # These commands will handle digitalocean DNS
  do | do-cli | do-api | digitalocean | digitalocean-cli | digitalocean-api)
    shift
    digitalocean_api "$@"
    RETVAL=$?
    exit ${RETVAL}
    break
    ;;
    # These commands will handle cloudflare DNS
  cf | cf-cli | cf-api | cloudflare | cloudflare-cli | cloudflare-api)
    shift
    cloudflare_api "$@"
    RETVAL=$?
    exit ${RETVAL}
    break
    ;;
  # These commands will handle directadmin DNS
  da | da-cli | da-api | directadmin | directadmin-cli | directadmin-api)
    shift
    directadmin_api "$@"
    RETVAL=$?
    exit ${RETVAL}
    break
    ;;
    # These commands will handle namecheap DNS
  nc | nc-cli | nc-api | namecheap | namecheap-cli | namecheap-api)
    shift
    namecheap_api "$@"
    RETVAL=$?
    exit ${RETVAL}
    break
    ;;
  --)
    break
    ;;
  -*)
    echo "[${SCRIPT_NAME}]: Invalid option ${ACTION}. Use --help to see the valid options"
    exit 1
    ;;
  *) ;;
  esac
  echo "[${SCRIPT_NAME}]: Error, invalid action [ ${ACTION} ]. Use --help to see the valid actions or options"
  exit 1
done
